import { QuestionV2 } from "@/lib/quiz-types";

export const cpe301Chapter1: QuestionV2[] = [
  {
    id: "cpe301_001",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Assembly language is considered to be:",
    options: [
      "A high-level language",
      "A machine-independent language",
      "The oldest programming language",
      "A portable language",
    ],
    correctAnswer: 2,
    explanation:
      "Assembly language is considered the oldest programming language because it was one of the first ways programmers could write instructions for computers using human-readable mnemonics instead of raw binary.",
  },
  {
    id: "cpe301_002",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Which of the following is NOT a well-known x86 assembler?",
    options: ["MASM", "TASM", "NASM", "JAVA"],
    correctAnswer: 3,
    explanation:
      "JAVA is not an assembler—it's a high-level programming language. MASM, TASM, and NASM are all well-known x86 assemblers.",
  },
  {
    id: "cpe301_003",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A utility program that converts source code programs from assembly language into machine language is called:",
    options: ["Compiler", "Interpreter", "Assembler", "Debugger"],
    correctAnswer: 2,
    explanation:
      "An assembler converts assembly language source code into machine language (object code). A compiler converts high-level language to machine code.",
  },
  {
    id: "cpe301_004",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Which utility lets you step through a program while it's running and examine registers and memory?",
    options: ["Assembler", "Linker", "Debugger", "Compiler"],
    correctAnswer: 2,
    explanation:
      "A debugger allows programmers to execute a program step by step, set breakpoints, and examine registers and memory to find and fix bugs.",
  },
  {
    id: "cpe301_005",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Which of the following is TRUE about assembly language portability?",
    options: [
      "Assembly language is highly portable",
      "Assembly language is designed for a specific processor family",
      "Assembly language programs can run on any computer",
      "Assembly language is as portable as Java",
    ],
    correctAnswer: 1,
    explanation:
      "Assembly language is NOT portable—it's designed for a specific processor family (like x86 or ARM). Code written for one architecture won't run on another.",
  },
  {
    id: "cpe301_006",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Programs written for small amounts of memory in single-purpose devices are called:",
    options: [
      "System programs",
      "Embedded programs",
      "Real-time programs",
      "Kernel programs",
    ],
    correctAnswer: 1,
    explanation:
      "Embedded programs are written for embedded systems—dedicated computers within devices with limited memory that perform specific functions.",
  },
  {
    id: "cpe301_007",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Device drivers:",
    options: [
      "Are written in high-level languages only",
      "Translate OS commands into hardware references",
      "Manage user applications",
      "Control the operating system",
    ],
    correctAnswer: 1,
    explanation:
      "Device drivers translate OS commands into hardware-specific instructions, allowing the OS to communicate with various hardware devices.",
  },
  {
    id: "cpe301_008",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Which mode is NOT supported by 64-bit Windows?",
    options: [
      "32-Bit Protected Mode",
      "64-Bit Long Mode",
      "16-Bit Real-Address Mode",
      "Virtual-8086 Mode",
    ],
    correctAnswer: 2,
    explanation:
      "64-bit Windows does NOT support 16-bit Real-Address Mode. It supports 32-bit protected mode for backward compatibility and 64-bit long mode.",
  },
  {
    id: "cpe301_009",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Which language provides the most direct access to hardware?",
    options: ["Java", "Python", "Assembly language", "C++"],
    correctAnswer: 2,
    explanation:
      "Assembly language provides the most direct hardware access, allowing programmers to manipulate registers, memory addresses, and hardware ports directly.",
  },
  {
    id: "cpe301_010",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "TASM stands for:",
    options: [
      "Turbo Assembler",
      "Terminal Assembly System",
      "Translate Assembly Module",
      "Text Assembly Manager",
    ],
    correctAnswer: 0,
    explanation:
      "TASM stands for Turbo Assembler, developed by Borland, supporting both MASM-compatible and its own 'Ideal' syntax mode.",
  },
  {
    id: "cpe301_011",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A single C++ statement typically expands into:",
    options: [
      "A single assembly instruction",
      "Multiple assembly instructions",
      "No assembly instructions",
      "Depends on optimization level",
    ],
    correctAnswer: 1,
    explanation:
      "A single C++ statement typically expands into multiple assembly instructions. Even a simple assignment may require load, compute, and store instructions.",
  },
  {
    id: "cpe301_012",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "GAS stands for:",
    options: [
      "Global Assembly System",
      "GNU Assembler",
      "General Assembly Service",
      "Graphics Assembly System",
    ],
    correctAnswer: 1,
    explanation:
      "GAS stands for GNU Assembler, the default assembler in the GNU toolchain used on Linux and Unix-like systems.",
  },
  {
    id: "cpe301_013",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Why is assembly language not used for large application programs?",
    options: [
      "It's not capable of complex operations",
      "It takes too much time to write and maintain",
      "It produces inefficient code",
      "It cannot access hardware",
    ],
    correctAnswer: 1,
    explanation:
      "Assembly takes too much time to write and maintain. Each operation requires explicit instructions, making development slow and code hard to modify.",
  },
  {
    id: "cpe301_014",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "In the virtual machine concept, L0 represents:",
    options: [
      "Assembly language",
      "High-level language",
      "Native machine language",
      "Intermediate code",
    ],
    correctAnswer: 2,
    explanation:
      "L0 (Level 0) represents native machine language—the actual binary instructions that the physical hardware can execute directly.",
  },
  {
    id: "cpe301_015",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A method that converts an entire program before execution is called:",
    options: [
      "Interpretation",
      "Translation",
      "Execution",
      "Runtime processing",
    ],
    correctAnswer: 1,
    explanation:
      "Translation (compilation) converts an entire program before execution. The translated program can then run independently.",
  },
  {
    id: "cpe301_016",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Level 1 in the virtual machine model represents:",
    options: [
      "Machine language",
      "Assembly language",
      "Digital logic hardware",
      "High-level language",
    ],
    correctAnswer: 2,
    explanation:
      "Level 1 represents digital logic hardware—the actual electronic circuits (logic gates, registers, buses) that implement the CPU.",
  },
  {
    id: "cpe301_017",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Assembly language is at:",
    options: ["Level 1", "Level 2", "Level 3", "Level 4"],
    correctAnswer: 2,
    explanation:
      "Assembly language is at Level 3, providing human-readable mnemonics that are translated (assembled) to Level 2 machine language.",
  },
  {
    id: "cpe301_018",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Compared to interpreted programs, translated programs:",
    options: [
      "Execute more slowly",
      "Execute more quickly",
      "Have the same execution speed",
      "Require the interpreter at runtime",
    ],
    correctAnswer: 1,
    explanation:
      "Translated programs execute more quickly because translation is done once before execution, avoiding runtime decoding overhead.",
  },
  {
    id: "cpe301_019",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A microprogram is:",
    options: [
      "A small assembly program",
      "Program embedded in the microprocessor chip",
      "A user-written program",
      "A system utility",
    ],
    correctAnswer: 1,
    explanation:
      "A microprogram is firmware embedded in the CPU that implements machine instructions using microinstructions to control internal operations.",
  },
  {
    id: "cpe301_020",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Which uses short mnemonics like ADD, SUB, MOV?",
    options: [
      "Machine language",
      "High-level language",
      "Assembly language",
      "Bytecode",
    ],
    correctAnswer: 2,
    explanation:
      "Assembly language uses short mnemonics like ADD, SUB, MOV—human-readable abbreviations representing machine instructions.",
  },
  {
    id: "cpe301_021",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Assembly programs are:",
    options: [
      "Interpreted as they run",
      "Translated (assembled) entirely before execution",
      "Executed by the CPU directly",
      "Compiled to bytecode",
    ],
    correctAnswer: 1,
    explanation:
      "Assembly programs are translated entirely before execution. The assembler converts source to machine code, which is then linked into an executable.",
  },
  {
    id: "cpe301_022",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A machine instruction is executed by:",
    options: [
      "Only hardware directly",
      "Only by microprogram",
      "Either hardware directly or by microprogram",
      "Only by the assembler",
    ],
    correctAnswer: 2,
    explanation:
      "Machine instructions can be executed either by hardware directly (hardwired) or by microprogram. Simple instructions may be hardwired for speed.",
  },
  {
    id: "cpe301_023",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The relationship between software and hardware layers",
    options: [
      "Directly executed by hardware",
      "Translated or interpreted by the next-lowest layer",
      "Never executed",
      "Stored in ROM",
    ],
    correctAnswer: 1,
    explanation:
      "Programs at any layer are translated or interpreted by the next-lowest layer, continuing down until reaching hardware execution.",
  },
  {
    id: "cpe301_024",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Binary numbers are base:",
    options: ["8", "10", "2", "16"],
    correctAnswer: 2,
    explanation:
      "Binary numbers are base 2, using only two digits: 0 and 1. Each position represents a power of 2.",
  },
  {
    id: "cpe301_025",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The leftmost bit of a binary number is the:",
    options: ["LSB", "MSB", "Bit 0", "Sign bit"],
    correctAnswer: 1,
    explanation:
      "The leftmost bit is the MSB (Most Significant Bit), having the highest positional value. In 8 bits, the MSB represents 2^7 (128).",
  },
  {
    id: "cpe301_026",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "LSB stands for:",
    options: [
      "Least Significant Bit",
      "Large Storage Byte",
      "Load System Bits",
      "Left Shift Bits",
    ],
    correctAnswer: 0,
    explanation:
      "LSB stands for Least Significant Bit—the rightmost bit with the smallest weight (2^0 = 1).",
  },
  {
    id: "cpe301_027",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "2^0 equals:",
    options: ["0", "1", "2", "10"],
    correctAnswer: 1,
    explanation: "2^0 equals 1. Any number raised to the power of 0 equals 1.",
  },
  {
    id: "cpe301_028",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "2^4 equals:",
    options: ["4", "8", "16", "24"],
    correctAnswer: 2,
    explanation:
      "2^4 = 16. This represents one hexadecimal digit (values 0-15).",
  },
  {
    id: "cpe301_029",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "2^10 equals:",
    options: ["512", "1000", "1024", "2048"],
    correctAnswer: 2,
    explanation:
      "2^10 = 1024, approximately 1000. This is why 1024 bytes is called a kilobyte.",
  },
  {
    id: "cpe301_030",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The decimal value of binary 00001111 is:",
    options: ["14", "15", "16", "17"],
    correctAnswer: 1,
    explanation: "00001111 = 8 + 4 + 2 + 1 = 15. The lower 4 bits are all set.",
  },
  {
    id: "cpe301_031",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The decimal value of unsigned binary 11111111 is:",
    options: ["127", "128", "254", "255"],
    correctAnswer: 3,
    explanation:
      "Unsigned 11111111 = 2^8 - 1 = 255. All 8 bits set gives the maximum unsigned byte value.",
  },
  {
    id: "cpe301_032",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "To convert a decimal number to binary, divide by:",
    options: ["8", "10", "2", "16"],
    correctAnswer: 2,
    explanation:
      "To convert decimal to binary, repeatedly divide by 2 and record remainders, reading them bottom to top.",
  },
  {
    id: "cpe301_033",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The binary representation of decimal 7 is:",
    options: ["00000110", "00000111", "00001000", "00001001"],
    correctAnswer: 1,
    explanation: "7 = 4 + 2 + 1 = 2^2 + 2^1 + 2^0 = 00000111.",
  },
  {
    id: "cpe301_034",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The binary representation of decimal 32 is:",
    options: ["00010000", "00100000", "01000000", "10000000"],
    correctAnswer: 1,
    explanation: "32 = 2^5 = 00100000. Only bit 5 is set.",
  },
  {
    id: "cpe301_035",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "In binary, 1 + 1 equals:",
    options: ["1", "2", "10", "11"],
    correctAnswer: 2,
    explanation:
      "In binary, 1 + 1 = 10 (decimal 2). Adding two 1s requires a carry to the next position.",
  },
  {
    id: "cpe301_036",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The formula for bits needed to represent n is:",
    options: ["n", "log₂ n", "ceiling(log₂ n)", "2^n"],
    correctAnswer: 2,
    explanation:
      "ceiling(log₂ n) gives the minimum bits needed to represent n values. The ceiling rounds up for fractional results.",
  },
  {
    id: "cpe301_037",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The decimal value of binary 01100100 is:",
    options: ["96", "100", "108", "110"],
    correctAnswer: 1,
    explanation: "01100100 = 64 + 32 + 4 = 100. Bits 6, 5, and 2 are set.",
  },
  {
    id: "cpe301_038",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The decimal value of binary 00110101 is:",
    options: ["50", "52", "53", "54"],
    correctAnswer: 2,
    explanation: "00110101 = 32 + 16 + 4 + 1 = 53. Bits 5, 4, 2, 0 are set.",
  },
  {
    id: "cpe301_039",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A signed binary integer can be:",
    options: [
      "Positive only",
      "Negative only",
      "Positive or negative",
      "Zero only",
    ],
    correctAnswer: 2,
    explanation:
      "Signed integers can be positive, negative, or zero. The MSB indicates the sign.",
  },
  {
    id: "cpe301_040",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Zero is considered:",
    options: [
      "Positive",
      "Negative",
      "Positive or neither positive nor negative",
      "Undefined",
    ],
    correctAnswer: 2,
    explanation:
      "Zero is typically considered neither positive nor negative, though in computing it's grouped with positives (sign bit = 0).",
  },
  {
    id: "cpe301_041",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The basic storage unit in an x86 computer is:",
    options: ["Bit", "Byte", "Word", "Kilobyte"],
    correctAnswer: 1,
    explanation:
      "The byte (8 bits) is the basic storage unit. Memory is byte-addressable.",
  },
  {
    id: "cpe301_042",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Number of bytes in a word:",
    options: ["1", "2", "4", "8"],
    correctAnswer: 1,
    explanation: "In x86 terminology, a word is 2 bytes (16 bits).",
  },
  {
    id: "cpe301_043",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Number of bytes in a doubleword:",
    options: ["2", "4", "8", "16"],
    correctAnswer: 1,
    explanation:
      "A doubleword (DWORD) is 4 bytes (32 bits), the native size for 32-bit processors.",
  },
  {
    id: "cpe301_044",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Number of bytes in a quadword:",
    options: ["4", "8", "16", "32"],
    correctAnswer: 1,
    explanation:
      "A quadword (QWORD) is 8 bytes (64 bits), native for 64-bit processors.",
  },
  {
    id: "cpe301_045",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Number of bits in a double quadword:",
    options: ["64", "128", "256", "512"],
    correctAnswer: 1,
    explanation:
      "A double quadword is 128 bits (16 bytes), used in SIMD/SSE operations.",
  },
  {
    id: "cpe301_046",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "One kilobyte equals 2 to the power of:",
    options: ["8", "9", "10", "11"],
    correctAnswer: 2,
    explanation: "1 KB = 2^10 = 1024 bytes.",
  },
  {
    id: "cpe301_047",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "One megabyte equals 2 to the power of:",
    options: ["15", "18", "20", "25"],
    correctAnswer: 2,
    explanation: "1 MB = 2^20 bytes. Pattern: KB=2^10, MB=2^20, GB=2^30.",
  },
  {
    id: "cpe301_048",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "One terabyte equals 2 to the power of:",
    options: ["30", "35", "40", "45"],
    correctAnswer: 2,
    explanation: "1 TB = 2^40 bytes ≈ 1 trillion bytes.",
  },
  {
    id: "cpe301_049",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The range of an unsigned word is:",
    options: ["0 to 32767", "0 to 65535", "-32768 to 32767", "-65536 to 65535"],
    correctAnswer: 1,
    explanation: "Unsigned word (16 bits): 0 to 65535 = 2^16 - 1.",
  },
  {
    id: "cpe301_050",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "One petabyte equals 2 to the power of:",
    options: ["40", "45", "50", "55"],
    correctAnswer: 2,
    explanation: "1 PB = 2^50 bytes ≈ 1000 TB.",
  },
  {
    id: "cpe301_051",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Hexadecimal numbers are base:",
    options: ["8", "10", "16", "2"],
    correctAnswer: 2,
    explanation: "Hexadecimal is base 16, using digits 0-9 and letters A-F.",
  },
  {
    id: "cpe301_052",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Two hexadecimal digits represent:",
    options: ["A word", "A nibble", "A byte", "A doubleword"],
    correctAnswer: 2,
    explanation: "Two hex digits = 8 bits = 1 byte. Example: FF = 11111111.",
  },
  {
    id: "cpe301_053",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The letter F in hexadecimal represents decimal:",
    options: ["14", "15", "16", "17"],
    correctAnswer: 1,
    explanation: "Hex F = decimal 15, the highest single hex digit.",
  },
  {
    id: "cpe301_054",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The letter C in hexadecimal represents decimal:",
    options: ["11", "12", "13", "14"],
    correctAnswer: 1,
    explanation: "Hex C = decimal 12 = binary 1100.",
  },
  {
    id: "cpe301_055",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The letter E in hexadecimal represents decimal:",
    options: ["13", "14", "15", "16"],
    correctAnswer: 1,
    explanation: "Hex E = decimal 14 = binary 1110.",
  },
  {
    id: "cpe301_056",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The binary equivalent of hexadecimal F is:",
    options: ["1110", "1111", "10000", "01111"],
    correctAnswer: 1,
    explanation: "Hex F = 15 = binary 1111 (all four bits set).",
  },
  {
    id: "cpe301_057",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The hexadecimal equivalent of binary 1111 is:",
    options: ["D", "E", "F", "10"],
    correctAnswer: 2,
    explanation: "Binary 1111 = 15 = hex F.",
  },
  {
    id: "cpe301_058",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "16^1 equals:",
    options: ["1", "16", "256", "4096"],
    correctAnswer: 1,
    explanation: "16^1 = 16. The second hex digit position has weight 16.",
  },
  {
    id: "cpe301_059",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "16^3 equals:",
    options: ["1024", "2048", "4096", "8192"],
    correctAnswer: 2,
    explanation: "16^3 = 4096. Fourth hex digit position weight.",
  },
  {
    id: "cpe301_060",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The decimal value of hexadecimal 10 is:",
    options: ["10", "15", "16", "17"],
    correctAnswer: 2,
    explanation:
      "Hex 10 = 1×16 + 0 = 16 decimal. Don't confuse with decimal 10!",
  },
  {
    id: "cpe301_061",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "To convert a decimal number to hexadecimal, divide by:",
    options: ["8", "10", "2", "16"],
    correctAnswer: 3,
    explanation:
      "Divide by 16, record remainders (convert 10-15 to A-F), read bottom to top.",
  },
  {
    id: "cpe301_062",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The hexadecimal representation of decimal 16 is:",
    options: ["F", "10", "11", "20"],
    correctAnswer: 1,
    explanation: "16 ÷ 16 = 1 R0, so decimal 16 = hex 10.",
  },
  {
    id: "cpe301_063",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The binary equivalent of hexadecimal 5 is:",
    options: ["0100", "0101", "0110", "0111"],
    correctAnswer: 1,
    explanation: "Hex 5 = 4 + 1 = binary 0101.",
  },
  {
    id: "cpe301_064",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Hexadecimal is useful because:",
    options: [
      "It is easier to remember",
      "Large binary numbers are cumbersome to read",
      "It reduces memory usage",
      "It speeds up computation",
    ],
    correctAnswer: 1,
    explanation:
      "Hex provides compact representation of binary—each digit is 4 bits.",
  },
  {
    id: "cpe301_065",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Hexadecimal digits include:",
    options: ["0-9 only", "A-F only", "0-9 and A-F", "0-7"],
    correctAnswer: 2,
    explanation: "Hex uses 0-9 for 0-9 and A-F for 10-15 (16 total symbols).",
  },
  {
    id: "cpe301_066",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "In signed binary representation, the MSB indicates:",
    options: [
      "The magnitude of the number",
      "The sign of the number",
      "The parity of the number",
      "The overflow status",
    ],
    correctAnswer: 1,
    explanation: "The MSB indicates sign: 0 = positive/zero, 1 = negative.",
  },
  {
    id: "cpe301_067",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "When MSB = 1, the number is:",
    options: ["Positive", "Negative", "Zero", "Undefined"],
    correctAnswer: 1,
    explanation: "MSB = 1 indicates negative in two's complement.",
  },
  {
    id: "cpe301_068",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Two's complement of an integer is its:",
    options: ["Opposite", "Additive inverse", "Reciprocal", "Compliment"],
    correctAnswer: 1,
    explanation:
      "Two's complement is the additive inverse: number + its two's complement = 0.",
  },
  {
    id: "cpe301_069",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "To create the two's complement of a number:",
    options: ["Invert bits and add 1", "Add 1", "Invert bits", "Subtract 1"],
    correctAnswer: 0,
    explanation: "Two's complement: (1) invert all bits, (2) add 1.",
  },
  {
    id: "cpe301_070",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Two's complement eliminates the need for:",
    options: [
      "Adders",
      "Multiplication circuits",
      "Separate subtraction circuits",
      "Logic gates",
    ],
    correctAnswer: 2,
    explanation:
      "Subtraction becomes addition: A - B = A + (-B). Same hardware works.",
  },
  {
    id: "cpe301_071",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The signed binary 11111111 (8-bit) equals:",
    options: ["-128", "-2", "-1", "255"],
    correctAnswer: 2,
    explanation:
      "11111111 = -1. Two's complement: invert→00000000, +1→00000001 = 1, so original = -1.",
  },
  {
    id: "cpe301_072",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The range of a signed byte is:",
    options: ["0 to 255", "-127 to 127", "-128 to 127", "-256 to 255"],
    correctAnswer: 2,
    explanation: "Signed byte: -128 to 127 (-2^7 to 2^7-1).",
  },
  {
    id: "cpe301_073",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The range of a signed word is:",
    options: [
      "0 to 65535",
      "-32767 to 32767",
      "-32768 to 32767",
      "-65536 to 65535",
    ],
    correctAnswer: 2,
    explanation: "Signed word (16 bits): -32768 to 32767 (-2^15 to 2^15-1).",
  },
  {
    id: "cpe301_074",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The binary representation of -43 (8-bit) is:",
    options: ["11010100", "11010101", "10101011", "11010011"],
    correctAnswer: 1,
    explanation: "43 = 00101011 → invert → 11010100 → +1 → 11010101 = -43.",
  },
  {
    id: "cpe301_075",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The hexadecimal 8A20 is:",
    options: ["Positive", "Negative", "Zero", "Undefined"],
    correctAnswer: 1,
    explanation: "8A20 starts with 8 (≥8), so MSB=1, meaning negative.",
  },
  {
    id: "cpe301_076",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The two's complement operation is:",
    options: ["Reversible", "Irreversible", "Ambiguous", "Undefined"],
    correctAnswer: 0,
    explanation:
      "Two's complement is reversible: applying it twice returns the original.",
  },
  {
    id: "cpe301_077",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "When creating a hex two's complement, subtract from:",
    options: ["10", "16", "F", "FF"],
    correctAnswer: 2,
    explanation:
      "Subtract each hex digit from F (15), then add 1 to the result.",
  },
  {
    id: "cpe301_078",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The decimal value of signed binary 11110000 is:",
    options: ["-240", "-16", "-15", "240"],
    correctAnswer: 1,
    explanation:
      "MSB=1 → negative. Invert: 00001111, +1: 00010000 = 16. So original = -16.",
  },
  {
    id: "cpe301_079",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The maximum positive value of a signed byte is:",
    options: ["128", "127", "255", "256"],
    correctAnswer: 1,
    explanation: "Max positive signed byte = 2^7 - 1 = 127 (01111111).",
  },
  {
    id: "cpe301_080",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The 8-bit two's complement of -1 is:",
    options: ["00000001", "10000000", "11111111", "11111110"],
    correctAnswer: 2,
    explanation:
      "-1 in 8-bit = 11111111. Verify: +1 = 00000001, invert → 11111110, +1 → 11111111.",
  },
  {
    id: "cpe301_081",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "ASCII stands for:",
    options: [
      "American Standard Computer Information Exchange",
      "American Standard Code for Information Interchange",
      "Advanced System Code for Interface Integration",
      "Alphanumeric Standard Character Information Exchange",
    ],
    correctAnswer: 1,
    explanation: "ASCII = American Standard Code for Information Interchange.",
  },
  {
    id: "cpe301_082",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "ASCII maps characters to:",
    options: [
      "Text strings",
      "Integers",
      "Floating-point numbers",
      "Memory addresses",
    ],
    correctAnswer: 1,
    explanation:
      "ASCII maps characters to integers (numeric codes). 'A' = 65, 'a' = 97.",
  },
  {
    id: "cpe301_083",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "ANSI stands for:",
    options: [
      "American National Standards Institute",
      "Advanced Number System for Information",
      "American Numeric Symbol Interface",
      "Alliance of National Standards Index",
    ],
    correctAnswer: 0,
    explanation: "ANSI = American National Standards Institute.",
  },
  {
    id: "cpe301_084",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Unicode was created to:",
    options: [
      "Simplify character encoding",
      "Define characters for all major languages",
      "Replace ASCII entirely",
      "Speed up text processing",
    ],
    correctAnswer: 1,
    explanation:
      "Unicode covers all major world languages with 100,000+ characters.",
  },
  {
    id: "cpe301_085",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "UTF-16 encodes each character in:",
    options: ["8 bits", "16 bits", "24 bits", "32 bits"],
    correctAnswer: 1,
    explanation:
      "UTF-16 uses 16 bits per character (some need surrogate pairs).",
  },
  {
    id: "cpe301_086",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A null-terminated string ends with:",
    options: [
      "A null space",
      "A single byte containing zero",
      "A carriage return",
      "A newline character",
    ],
    correctAnswer: 1,
    explanation: "Null-terminated strings end with byte 0x00 to mark the end.",
  },
  {
    id: "cpe301_087",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The ASCII code for 'A' (uppercase) is:",
    options: ["40h", "41h", "42h", "61h"],
    correctAnswer: 1,
    explanation: "'A' = 41h (65 decimal). Uppercase A-Z are 65-90.",
  },
  {
    id: "cpe301_088",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "ASCII control characters range from:",
    options: [
      "0 through 15",
      "0 through 31",
      "32 through 63",
      "128 through 159",
    ],
    correctAnswer: 1,
    explanation: "Control characters are 0-31 (and 127 DEL). Non-printable.",
  },
  {
    id: "cpe301_089",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "ASCII code 10 is:",
    options: ["Backspace", "Carriage return", "Line feed", "Horizontal tab"],
    correctAnswer: 2,
    explanation: "ASCII 10 = Line Feed (LF). Unix uses LF alone for newlines.",
  },
  {
    id: "cpe301_090",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "ASCII code 9 is:",
    options: ["Backspace", "Line feed", "Carriage return", "Horizontal tab"],
    correctAnswer: 3,
    explanation: "ASCII 9 = Horizontal Tab (HT).",
  },
  {
    id: "cpe301_091",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Boolean algebra was invented by:",
    options: [
      "Isaac Newton",
      "George Boole",
      "Albert Einstein",
      "Bertrand Russell",
    ],
    correctAnswer: 1,
    explanation:
      "George Boole invented Boolean algebra in the 1800s—foundation of digital computing.",
  },
  {
    id: "cpe301_092",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The NOT operator is:",
    options: ["Binary", "Ternary", "Unary", "Quaternary"],
    correctAnswer: 2,
    explanation:
      "NOT is unary (one operand). AND and OR are binary (two operands).",
  },
  {
    id: "cpe301_093",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The NOT operation:",
    options: [
      "Combines two values",
      "Reverses a boolean value",
      "Checks equality",
      "Compares values",
    ],
    correctAnswer: 1,
    explanation: "NOT reverses/inverts: true→false, false→true.",
  },
  {
    id: "cpe301_094",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "NOT FALSE equals:",
    options: ["FALSE", "TRUE", "UNDEFINED", "NULL"],
    correctAnswer: 1,
    explanation: "NOT FALSE = TRUE.",
  },
  {
    id: "cpe301_095",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "TRUE AND TRUE equals:",
    options: ["FALSE", "TRUE", "UNDEFINED", "NULL"],
    correctAnswer: 1,
    explanation: "T AND T = T. Only case where AND returns true.",
  },
  {
    id: "cpe301_096",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "FALSE AND FALSE equals:",
    options: ["TRUE", "FALSE", "UNDEFINED", "NULL"],
    correctAnswer: 1,
    explanation: "F AND F = F.",
  },
  {
    id: "cpe301_097",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "TRUE OR FALSE equals:",
    options: ["FALSE", "TRUE", "UNDEFINED", "NULL"],
    correctAnswer: 1,
    explanation: "T OR F = T. OR returns true if at least one input is true.",
  },
  {
    id: "cpe301_098",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "FALSE OR TRUE equals:",
    options: ["FALSE", "TRUE", "UNDEFINED", "NULL"],
    correctAnswer: 1,
    explanation: "F OR T = T. OR is commutative.",
  },
  {
    id: "cpe301_099",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The operator precedence order is:",
    options: ["AND, OR, NOT", "OR, AND, NOT", "NOT, AND, OR", "NOT, OR, AND"],
    correctAnswer: 2,
    explanation: "Precedence: NOT (highest), AND, OR (lowest).",
  },
  {
    id: "cpe301_100",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "11111111 AND 00011100 equals:",
    options: ["00011100", "11111111", "11100011", "00000000"],
    correctAnswer: 0,
    explanation: "Bitwise AND with all 1s preserves the original value.",
  },
  {
    id: "cpe301_101",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A truth table shows:",
    options: [
      "How to calculate truth values",
      "All possible inputs and outputs",
      "Common Boolean expressions",
      "Logic gate designs",
    ],
    correctAnswer: 1,
    explanation:
      "Truth table lists all input combinations and corresponding outputs.",
  },
  {
    id: "cpe301_102",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A Boolean function with 3 inputs has ___ rows in its truth table:",
    options: ["4", "6", "8", "16"],
    correctAnswer: 2,
    explanation: "3 inputs → 2^3 = 8 rows.",
  },
  {
    id: "cpe301_103",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A multiplexer uses:",
    options: [
      "Multiple inputs to select one output",
      "A selector bit to select output",
      "Multiple outputs from one input",
      "A truth table to generate output",
    ],
    correctAnswer: 1,
    explanation:
      "A MUX uses selector bits to choose which input passes to output.",
  },
  {
    id: "cpe301_104",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "¬(F ∨ T) equals:",
    options: ["TRUE", "FALSE", "UNDEFINED", "NULL"],
    correctAnswer: 1,
    explanation: "F OR T = T, then NOT T = F.",
  },
  {
    id: "cpe301_105",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Boolean algebra is used in:",
    options: [
      "Only digital circuit design",
      "Only programming",
      "Both digital circuit design and programs",
      "Only mathematics",
    ],
    correctAnswer: 2,
    explanation:
      "Boolean algebra is fundamental to both circuits and programming.",
  },
  {
    id: "cpe301_106",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A binary integer is:",
    options: [
      "Stored in memory in raw format",
      "Always encoded as ASCII",
      "Stored as text",
      "Compressed for storage",
    ],
    correctAnswer: 0,
    explanation:
      "Binary integers are stored as raw binary—actual bits representing the value.",
  },
  {
    id: "cpe301_107",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A digit string is:",
    options: [
      "A binary representation",
      "A string of ASCII characters",
      "A memory address",
      "A hexadecimal code",
    ],
    correctAnswer: 1,
    explanation:
      "\\\"65\\\" = two characters '6' and '5', different from binary integer 65.",
  },
  {
    id: "cpe301_108",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The hexadecimal digit string for decimal 65 is:",
    options: [],
    correctAnswer: 0,
    explanation: "65 = 1×64 + 0×8 + 1×1 = 101 octal.",
  },
  {
    id: "cpe301_109",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Octal uses digits:",
    options: ["0-9", "0-7", "0-F", "1-8"],
    correctAnswer: 1,
    explanation: "Octal uses 0-7 (eight symbols for base 8).",
  },
  {
    id: "cpe301_110",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A debugger displays byte 01000001 as:",
    options: ["01000001", "41", "65"],
    correctAnswer: 1,
    explanation: "Debuggers typically show hex: 01000001 = 41h.",
  },
  {
    id: "cpe301_111",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Number interpretation depends on:",
    options: [
      "Its numeric value",
      "The context in which it appears",
      "Its size",
      "The CPU used",
    ],
    correctAnswer: 1,
    explanation:
      "Context determines meaning: same byte could be number, character, or opcode.",
  },
  {
    id: "cpe301_112",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A simpler method of binary subtraction is:",
    options: [
      "Reverse the subtrahend and subtract",
      "Reverse the subtrahend sign and add",
      "Use only borrowing",
      "Use a calculator",
    ],
    correctAnswer: 1,
    explanation: "A - B = A + (-B). Negate B using two's complement and add.",
  },
  {
    id: "cpe301_113",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Binary 0 - 1 occurs when:",
    options: [
      "Adding one and zero",
      "Subtracting one from zero",
      "Borrowing from next position",
      "The result is undefined",
    ],
    correctAnswer: 2,
    explanation: "0 - 1 requires borrowing from the next higher bit position.",
  },
  {
    id: "cpe301_114",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Two's complement subtraction needs:",
    options: [
      "Extra adders",
      "Extra bit for sign",
      "Special logic",
      "Additional memory",
    ],
    correctAnswer: 1,
    explanation:
      "Need an extra bit for sign to handle signed arithmetic properly.",
  },
  {
    id: "cpe301_115",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Binary 00001101 - 00000111 equals:",
    options: ["00000101", "00000110", "00000111", "00001000"],
    correctAnswer: 1,
    explanation: "00001101 (13) - 00000111 (7) = 00000110 (6).",
  },
  {
    id: "cpe301_116",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "Two's complement subtraction advantage:",
    options: [
      "Uses less memory",
      "Uses same circuitry as addition",
      "Is faster on all processors",
      "Eliminates the need for CPU",
    ],
    correctAnswer: 1,
    explanation: "Same adder hardware handles both addition and subtraction.",
  },
  {
    id: "cpe301_117",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "2^5 equals:",
    options: ["16", "32", "64", "128"],
    correctAnswer: 1,
    explanation: "2^5 = 32.",
  },
  {
    id: "cpe301_118",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "2^7 equals:",
    options: ["64", "128", "256", "512"],
    correctAnswer: 1,
    explanation: "2^7 = 128.",
  },
  {
    id: "cpe301_119",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The decimal representation of hexadecimal 64 is:",
    options: ["64", "96", "100", "104"],
    correctAnswer: 2,
    explanation: "Hex 64 = 6×16 + 4 = 100 decimal.",
  },
  {
    id: "cpe301_120",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The binary representation of hexadecimal 7 is:",
    options: ["0110", "0111", "1000", "1001"],
    correctAnswer: 1,
    explanation: "Hex 7 = binary 0111.",
  },
  {
    id: "cpe301_121",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "A nibble consists of:",
    options: ["1 bit", "2 bits", "4 bits", "8 bits"],
    correctAnswer: 2,
    explanation: "A nibble = 4 bits = half a byte = one hex digit.",
  },
  {
    id: "cpe301_122",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The formula dec = (D₁ × B¹) + (D₀ × B⁰) converts:",
    options: [
      "Decimal to binary",
      "Any base to decimal",
      "Binary to hexadecimal",
      "Decimal to any base",
    ],
    correctAnswer: 1,
    explanation:
      "This positional notation formula converts any base B to decimal.",
  },
  {
    id: "cpe301_123",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The decimal value of binary 11110000 is:",
    options: ["225", "230", "235", "240"],
    correctAnswer: 3,
    explanation: "11110000 = 128 + 64 + 32 + 16 = 240.",
  },
  {
    id: "cpe301_124",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The hexadecimal representation of binary 11110000 is:",
    options: ["EE", "EF", "F0", "FF"],
    correctAnswer: 2,
    explanation: "1111 = F, 0000 = 0 → F0.",
  },
  {
    id: "cpe301_125",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "One yottabyte equals 2 to the power of:",
    options: ["70", "75", "80", "85"],
    correctAnswer: 2,
    explanation: "1 YB = 2^80 bytes (largest standard unit).",
  },
  {
    id: "cpe301_126",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The ASCII code for digit '0' is:",
    options: ["2Eh", "30h", "38h", "39h"],
    correctAnswer: 1,
    explanation: "'0' = 30h (48 decimal). Digits 0-9 are 48-57.",
  },
  {
    id: "cpe301_127",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "The difference between ASCII 'A' and 'a' is:",
    options: ["10h", "1Fh", "20h", "30h"],
    correctAnswer: 2,
    explanation: "'a' - 'A' = 97 - 65 = 32 = 20h.",
  },
  {
    id: "cpe301_128",
    course: "CPE 301",
    chapter: "Chapter 1",
    text: "TRUE XOR TRUE equals:",
    options: ["TRUE", "FALSE", "UNDEFINED", "NULL"],
    correctAnswer: 1,
    explanation: "XOR = false when inputs are same. T XOR T = F.",
  },
];

export default cpe301Chapter1;
