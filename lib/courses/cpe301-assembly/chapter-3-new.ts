import { QuestionV2 } from "@/lib/quiz-types";

const cpe301Chapter3: QuestionV2[] = [
  // SECTION 3.1: Basic Language Elements
  {
    id: "CPE301_001",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which of the following best distinguishes an Assembly Language 'directive' from an 'instruction'?",
    options: [
      "Directives are executed by the CPU at runtime, while instructions are handled by the assembler.",
      "Instructions are executed by the CPU at runtime, while directives are commands recognized by the assembler at build time.",
      "Directives always generate machine code, whereas instructions do not.",
      "There is no functional difference; the terms are interchangeable in MASM.",
    ],
    correctAnswer: 1,
    explanation:
      "Directives (like .data, DWORD, .code) guide the assembler's process but do not run on the CPU. Instructions (like MOV, ADD) are translated into machine code and executed by the processor.",
  },
  {
    id: "CPE301_002",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which of the following is a valid integer literal in MASM syntax assuming the default radix is decimal?",
    options: ["1A", "30h", "101b", "Both B and C"],
    correctAnswer: 3,
    explanation:
      "'30h' is a valid hexadecimal literal (30 hex = 48 decimal) and '101b' is a valid binary literal (101 binary = 5 decimal). '1A' is NOT a valid integer literal because it contains a non-decimal character ('A') but has no radix suffix ('h' for hex). Without the 'h' suffix, MASM treats it as an identifier, not a number.",
  },
  {
    id: "CPE301_003",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "According to MASM identifier rules, which of the following is an INVALID identifier?",
    options: ["_myVar", "@Count", "1stValue", "my_Var2"],
    correctAnswer: 2,
    explanation:
      "Identifiers cannot begin with a numeric digit. They must begin with a letter, underscore, @, ?, or $.",
  },
  {
    id: "CPE301_004",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the primary function of the NOP instruction?",
    options: [
      "It halts the processor.",
      "It clears the EAX register.",
      "It consumes one byte of storage and performs no operation, often used for alignment.",
      "It performs a non-maskable interrupt.",
    ],
    correctAnswer: 2,
    explanation:
      "NOP (No Operation) takes up 1 byte and does nothing. It is used by compilers/assemblers to align code to efficient address boundaries.",
  },
  {
    id: "CPE301_005",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which of the following is NOT a reserved word in MASM?",
    options: ["MOV", "EAX", "LoopCounter", ".CODE"],
    correctAnswer: 2,
    explanation:
      "MOV (mnemonic), EAX (register), and .CODE (directive) are reserved words. LoopCounter is a user-defined identifier.",
  },
  {
    id: "CPE301_006",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: In MASM, a code label must always end with a colon (:), whereas a data label typically does not.",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation:
      "Code labels (targets for jumps) must end with a colon. Data labels (variable names) do not end with a colon.",
  },
  {
    id: "CPE301_007",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the machine code hexadecimal value for the NOP instruction?",
    options: ["00", "90", "CC", "FF"],
    correctAnswer: 1,
    explanation:
      "The text explicitly mentions: '00000003 90 nop'. The opcode for NOP is 90h.",
  },
  {
    id: "CPE301_008",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive marks the beginning of the code segment?",
    options: [".DATA", ".CODE", ".STACK", ".MODEL"],
    correctAnswer: 1,
    explanation:
      ".CODE identifies the area of a program containing executable instructions.",
  },
  {
    id: "CPE301_009",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "When defining a real number literal in MASM, how is 'encoded real' format represented?",
    options: [
      "Using the suffix 'r' (e.g., 3F800000r)",
      "Using the suffix 'f' (e.g., 3.14f)",
      "Using IEEE 754 standard binary format directly",
      "Using decimal notation only",
    ],
    correctAnswer: 0,
    explanation:
      "An encoded real represents a real number in hexadecimal using the 'r' suffix (e.g., 3F800000r).",
  },
  {
    id: "CPE301_010",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "In the instruction 'MOV EAX, 5', what role does '5' play?",
    options: [
      "Instruction Mnemonic",
      "Destination Operand",
      "Source Operand",
      "Label",
    ],
    correctAnswer: 2,
    explanation:
      "In 'MOV destination, source', 5 is the source operand (the value being moved).",
  },

  // SECTION 3.2: Example Program & Debugging
  {
    id: "CPE301_011",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the purpose of the 'ExitProcess' function in a MASM program?",
    options: [
      "To clear all registers before closing",
      "To print 'Press any key to continue'",
      "To halt the program and return control (and a return code) to the operating system",
      "To switch from Protected Mode to Real Mode",
    ],
    correctAnswer: 2,
    explanation:
      "ExitProcess is a Windows service that halts the program and returns control to the OS.",
  },
  {
    id: "CPE301_012",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "The directive '.386' in an assembly program indicates:",
    options: [
      "The program is 386 lines long.",
      "The program targets a 32-bit processor architecture (Intel 80386 or later).",
      "The program uses 386 bytes of stack space.",
      "The program is compatible with 16-bit processors only.",
    ],
    correctAnswer: 1,
    explanation:
      ".386 identifies the program as a 32-bit program that can access 32-bit registers and addresses.",
  },
  {
    id: "CPE301_013",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "In the 'flat' memory model used by 32-bit Windows programs, which mode of the processor is primarily used?",
    options: [
      "Real Mode",
      "Protected Mode",
      "Virtual-8086 Mode",
      "System Management Mode",
    ],
    correctAnswer: 1,
    explanation:
      "The flat memory model is associated with the processor's Protected Mode.",
  },
  {
    id: "CPE301_014",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: The 'PROTO' directive is used to define the implementation details of a procedure within the current source file.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 2,
    explanation:
      "False. PROTO declares a *prototype* (name and parameters) for a function, often one defined externally or in a library. The PROC directive is used to define the implementation.",
  },
  {
    id: "CPE301_015",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "While debugging in Visual Studio, what does the 'Step Over' command do?",
    options: [
      "It skips the next instruction entirely, not executing it.",
      "It executes the current line; if the line is a procedure call, it executes the entire procedure at once without stepping inside.",
      "It steps into the details of any procedure called on the current line.",
      "It restarts the program from the beginning.",
    ],
    correctAnswer: 1,
    explanation:
      "Step Over executes the current instruction. If it's a function call, it runs the function and pauses at the line *after* the call, avoiding stepping into the function code.",
  },
  {
    id: "CPE301_016",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What does a return value of '0' passed to ExitProcess usually indicate?",
    options: [
      "A fatal error occurred",
      "The program needs to restart",
      "The program executed successfully",
      "The memory was full",
    ],
    correctAnswer: 2,
    explanation:
      "A return code of 0 usually indicates success. Non-zero values indicate error codes.",
  },

  // SECTION 3.3: Assembling, Linking, Running
  {
    id: "CPE301_017",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which utility is responsible for combining object files and link libraries into a final executable file?",
    options: ["The Assembler", "The Compiler", "The Linker", "The Loader"],
    correctAnswer: 2,
    explanation:
      "The Linker combines object files and resolves calls to library procedures to create the executable.",
  },
  {
    id: "CPE301_018",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What file type is produced directly by the Assembler?",
    options: [
      "Source File (.asm)",
      "Object File (.obj)",
      "Executable File (.exe)",
      "Library File (.lib)",
    ],
    correctAnswer: 1,
    explanation: "The assembler reads source files and produces object files.",
  },
  {
    id: "CPE301_019",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which file contains a copy of the source code, line numbers, numeric addresses, machine code bytes, and a symbol table?",
    options: [
      "The Object File",
      "The Executable File",
      "The Listing File",
      "The Project File",
    ],
    correctAnswer: 2,
    explanation:
      "The Listing File contains detailed information about the assembly process, including machine code and addresses alongside source code.",
  },
  {
    id: "CPE301_020",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which component reads the executable file into memory and branches the CPU to the program's starting address?",
    options: [
      "The Assembler",
      "The Linker",
      "The OS Loader",
      "The Text Editor",
    ],
    correctAnswer: 2,
    explanation:
      "Step 4 of the cycle: The operating system loader reads the executable into memory and starts execution.",
  },
  {
    id: "CPE301_021",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If a source file is modified, which steps must occur before the changes are reflected in the executable?",
    options: [
      "Linking only",
      "Assembling only",
      "Assembling and Linking",
      "Loading only",
    ],
    correctAnswer: 2,
    explanation:
      "The source must be re-assembled into an object file, and the object file must be re-linked into an executable.",
  },

  // SECTION 3.4: Defining Data - Types and Storage
  {
    id: "CPE301_022",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which data directive is used to define a 32-bit unsigned integer?",
    options: ["WORD", "DWORD", "QWORD", "SBYTE"],
    correctAnswer: 1,
    explanation: "DWORD (Double Word) defines a 32-bit integer.",
  },
  {
    id: "CPE301_023",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "How many bits of storage does a 'QWORD' occupy?",
    options: ["16 bits", "32 bits", "64 bits", "80 bits"],
    correctAnswer: 2,
    explanation: "QWORD (Quad Word) is 64 bits (8 bytes).",
  },
  {
    id: "CPE301_024",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which legacy directive corresponds to the intrinsic type 'WORD'?",
    options: ["DB", "DW", "DD", "DQ"],
    correctAnswer: 1,
    explanation: "DW (Define Word) corresponds to the WORD type (16-bit).",
  },
  {
    id: "CPE301_025",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the primary usage of the 'TBYTE' directive?",
    options: [
      "Defining a 10-byte integer for Packed BCD",
      "Defining a text string",
      "Defining a tiny byte (4 bits)",
      "Defining a tera-byte storage area",
    ],
    correctAnswer: 0,
    explanation:
      "TBYTE defines an 80-bit (10-byte) integer, often used for Packed BCD or Extended Precision Floats.",
  },
  {
    id: "CPE301_026",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: The '?' initializer in a data definition causes the variable to be initialized to zero.",
    options: ["False", "Maybe", "I don't know", "True"],
    correctAnswer: 0,
    explanation:
      "The '?' initializer leaves the variable uninitialized (undefined value), not necessarily zero.",
  },
  {
    id: "CPE301_027",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Consider the definition: `myArray WORD 10, 20, 30`. If `myArray` is at offset 0000, what is the offset of the value `30`?",
    options: ["0002", "0003", "0004", "0006"],
    correctAnswer: 2,
    explanation:
      "WORD is 2 bytes. 10 is at 0000. 20 is at 0002. 30 is at 0004.",
  },
  {
    id: "CPE301_028",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which operator is used to allocate storage for multiple data items using a counter?",
    options: ["REP", "LOOP", "DUP", "TIMES"],
    correctAnswer: 2,
    explanation:
      "The DUP operator creates repeated storage allocation (e.g., `20 DUP(0)`).",
  },
  {
    id: "CPE301_029",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "How are x86 integers stored in memory?",
    options: [
      "Big-Endian Order",
      "Little-Endian Order",
      "Random Order",
      "Sequential Bit Order",
    ],
    correctAnswer: 1,
    explanation:
      "x86 processors use Little-Endian order (least significant byte at the lowest address).",
  },
  {
    id: "CPE301_030",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If EAX contains 12345678h, and it is stored in memory at address 0000 using Little-Endian, what byte is at address 0000?",
    options: ["12h", "34h", "56h", "78h"],
    correctAnswer: 3,
    explanation:
      "Little-Endian stores the LSB (78h) at the lowest address (0000).",
  },
  {
    id: "CPE301_031",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive allows for the declaration of uninitialized data to reduce the size of the compiled program?",
    options: [".DATA", ".DATA?", ".CONST", ".CODE"],
    correctAnswer: 1,
    explanation:
      ".DATA? is used for uninitialized data. It does not occupy space in the compiled executable on disk, unlike initialized data.",
  },
  {
    id: "CPE301_032",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Consider `val1 SWORD -32768`. What does SWORD indicate?",
    options: ["String Word", "Signed Word", "Short Word", "Static Word"],
    correctAnswer: 1,
    explanation: "SWORD stands for Signed Word (16-bit signed integer).",
  },
  {
    id: "CPE301_033",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "How many bytes of storage does a 'REAL8' variable require?",
    options: ["4 bytes", "8 bytes", "10 bytes", "16 bytes"],
    correctAnswer: 1,
    explanation:
      "REAL8 defines an 8-byte double-precision floating-point value.",
  },
  {
    id: "CPE301_034",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which of the following defines a string that is null-terminated?",
    options: [
      "myStr BYTE 'Hello', 0",
      "myStr BYTE 'Hello'",
      "myStr BYTE 'Hello', 10",
      "myStr STRING 'Hello'",
    ],
    correctAnswer: 0,
    explanation: "Null-terminated strings must end with a 0 byte.",
  },

  // SECTION 3.5: Symbolic Constants
  {
    id: "CPE301_035",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive associates a symbol name with an integer expression and ALLOWS redefinition later in the program?",
    options: ["EQU", "=", "TEXTEQU", "CONST"],
    correctAnswer: 1,
    explanation:
      "The equal-sign directive (=) allows symbols to be redefined. EQU does not.",
  },
  {
    id: "CPE301_036",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What does the symbol '$' represent in MASM data definitions?",
    options: [
      "The end of the file",
      "The start of the data segment",
      "The current location counter",
      "A hexadecimal prefix",
    ],
    correctAnswer: 2,
    explanation:
      "$ is the current location counter, representing the current offset address.",
  },
  {
    id: "CPE301_037",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Given `list BYTE 10, 20, 30, 40`, which expression correctly calculates the size of the array?",
    options: [
      "ListSize = ($ - list)",
      "ListSize = ($ + list)",
      "ListSize = list - $",
      "ListSize = sizeof(list)",
    ],
    correctAnswer: 0,
    explanation:
      "($ - list) calculates the difference between the current location (after the array) and the start of the array.",
  },
  {
    id: "CPE301_038",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive creates a 'text macro' that can be assigned arbitrary text?",
    options: ["=", "DWORD", "TEXTEQU", "MACRO"],
    correctAnswer: 2,
    explanation:
      "TEXTEQU creates a text macro where the symbol is replaced by the assigned text.",
  },
  {
    id: "CPE301_039",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: A symbol defined with the EQU directive cannot be redefined later in the same source code file.",
    options: ["True", "I don't know", "Maybe", "False"],
    correctAnswer: 0,
    explanation:
      "True. EQU constants are permanent within the source file and cannot be redefined, unlike =.",
  },
  {
    id: "CPE301_040",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "When calculating the number of elements in a DWORD array using `$`, why must you divide by 4?",
    options: [
      "Because the array has 4 elements.",
      "Because each DWORD occupies 4 bytes.",
      "Because of 4-byte alignment padding.",
      "Because the assembler scales by 4 automatically.",
    ],
    correctAnswer: 1,
    explanation:
      "($ - list) gives the size in bytes. Since a DWORD is 4 bytes, you divide by 4 to get the number of elements.",
  },

  // SECTION 3.6: 64-bit Programming
  {
    id: "CPE301_041",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "In 64-bit MASM programming, which register is used as the 64-bit accumulator (equivalent to EAX)?",
    options: ["EAX", "RAX", "R64", "AX"],
    correctAnswer: 1,
    explanation: "RAX is the 64-bit version of the EAX register.",
  },
  {
    id: "CPE301_042",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive is NOT supported in the 64-bit version of MASM?",
    options: [".DATA", "PROC", "INVOKE", "END"],
    correctAnswer: 2,
    explanation:
      "The text states: 'The 64-bit version of MASM does not support the INVOKE directive.'",
  },
  {
    id: "CPE301_043",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "How does the `PROTO` directive differ in 64-bit programs compared to 32-bit?",
    options: [
      "It is not used at all.",
      "It does not list parameters.",
      "It requires double the parameters.",
      "It must be capitalized.",
    ],
    correctAnswer: 1,
    explanation:
      "In 64-bit MASM, statements using PROTO do not have parameters (e.g., `ExitProcess PROTO`).",
  },
  {
    id: "CPE301_044",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive defines an 80-bit integer?",
    options: ["QWORD", "REAL10", "TBYTE", "DOUBLE"],
    correctAnswer: 2,
    explanation: "TBYTE (Ten Byte) defines an 80-bit integer.",
  },

  // MIXED & SCENARIO QUESTIONS
  {
    id: "CPE301_045",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "You are defining an array of 50 uninitialized 32-bit integers. Which declaration is most efficient?",
    options: [
      "myArray DWORD 50 DUP(0)",
      "myArray DWORD 50 DUP(?)",
      "myArray SDWORD 50 DUP(1)",
      "myArray DWORD 50",
    ],
    correctAnswer: 1,
    explanation:
      "DUP(?) creates uninitialized data, which is preferred for efficiency if specific initial values aren't needed.",
  },
  {
    id: "CPE301_046",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If you want to define a constant for PI (3.1416), which directive is most appropriate?",
    options: [
      "PI DWORD 3.1416",
      "PI EQU <3.1416>",
      "PI = 3.1416",
      "PI BYTE 3.1416",
    ],
    correctAnswer: 1,
    explanation:
      "The equal-sign directive (=) is for integers. EQU with text brackets <...> works for real number text substitution.",
  },
  {
    id: "CPE301_047",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the sequence of bytes for `val1 DWORD 12345678h` in Little-Endian memory?",
    options: ["12 34 56 78", "78 56 34 12", "12 56 34 78", "78 34 56 12"],
    correctAnswer: 1,
    explanation: "LSB (78) first, then 56, 34, MSB (12) last.",
  },
  {
    id: "CPE301_048",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which of the following lines causes a syntax error?",
    options: [
      "var1 BYTE 255",
      "var2 SBYTE -128",
      "var3 BYTE 300",
      "var4 WORD 65535",
    ],
    correctAnswer: 2,
    explanation: "BYTE fits 0-255. 300 exceeds the 8-bit limit.",
  },
  {
    id: "CPE301_050",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: The `.stack 4096` directive reserves 4096 bits of stack space.",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation: "False. It reserves 4096 *bytes*, not bits.",
  },
  {
    id: "CPE301_051",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the size of the following array in bytes? `myArray WORD 10 DUP(?)`",
    options: ["10 bytes", "20 bytes", "40 bytes", "80 bytes"],
    correctAnswer: 1,
    explanation: "WORD is 2 bytes. 10 elements * 2 bytes = 20 bytes.",
  },
  {
    id: "CPE301_052",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which legacy directive creates a 64-bit variable?",
    options: ["DD", "DW", "DQ", "DT"],
    correctAnswer: 2,
    explanation: "DQ (Define Quadword) creates a 64-bit variable.",
  },
  {
    id: "CPE301_053",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the purpose of the `END main` directive?",
    options: [
      "It terminates the main procedure only.",
      "It ends the program assembly and specifies the program entry point.",
      "It stops the debugger.",
      "It declares the end of the stack segment.",
    ],
    correctAnswer: 1,
    explanation:
      "END marks the end of the source module and the label 'main' specifies where execution begins.",
  },
  {
    id: "CPE301_054",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which instruction is used to move a value from one location to another?",
    options: ["CPY", "MOV", "LD", "STO"],
    correctAnswer: 1,
    explanation: "MOV is the mnemonic for the move instruction.",
  },
  {
    id: "CPE301_055",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which of the following is an example of an instruction mnemonic?",
    options: ["ADD", ".code", "DWORD", "eax"],
    correctAnswer: 0,
    explanation:
      "ADD is an instruction. .code is a directive. DWORD is a type/directive. eax is a register/operand.",
  },
  {
    id: "CPE301_056",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "When defining a packed BCD integer, which directive must be used?",
    options: ["QWORD", "BCD", "TBYTE", "REAL10"],
    correctAnswer: 2,
    explanation: "TBYTE is used for 80-bit packed BCD integers.",
  },
  {
    id: "CPE301_058",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "In the Listing File, what does the first column typically represent?",
    options: [
      "The source code line number",
      "The memory address offset",
      "The machine code",
      "The opcode",
    ],
    correctAnswer: 1,
    explanation:
      "Typically, the listing shows address offset, then machine code, then source.",
  },
  {
    id: "CPE301_059",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: A `WORD` variable can hold the value 70000.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation: "False. An unsigned WORD (16-bit) maxes out at 65535.",
  },
  {
    id: "CPE301_060",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "How many significant digits does a `REAL4` (Short Real) typically support?",
    options: ["6", "10", "15", "19"],
    correctAnswer: 0,
    explanation:
      "REAL4 (IEEE short real) supports approx 6 significant digits.",
  },

  // Continuing with more variations and depth...
  {
    id: "CPE301_061",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If you declare `val1 SBYTE -128`, what is the binary representation in memory (Two's Complement)?",
    options: ["10000000", "01111111", "11111111", "00000001"],
    correctAnswer: 0,
    explanation: "-128 in 8-bit two's complement is 10000000.",
  },
  {
    id: "CPE301_062",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which of the following is the correct syntax to define a 16-bit variable named `myCount` initialized to 0?",
    options: [
      "myCount DW 0",
      "myCount WORD 0",
      "myCount : WORD 0",
      "Both A and B",
    ],
    correctAnswer: 3,
    explanation:
      "Both `WORD` and legacy `DW` can be used to define a 16-bit variable.",
  },
  {
    id: "CPE301_063",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the function of the `stdcall` keyword in the `.model` directive?",
    options: [
      "It specifies the 32-bit flat memory model.",
      "It specifies the calling convention for procedures (how parameters are passed).",
      "It enables standard I/O library functions.",
      "It optimizes the code for speed.",
    ],
    correctAnswer: 1,
    explanation:
      "stdcall specifies the calling convention, crucial for Windows API calls.",
  },
  {
    id: "CPE301_064",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "In the instruction `ADD EAX, EBX`, which is the destination operand?",
    options: ["ADD", "EAX", "EBX", "Both EAX and EBX"],
    correctAnswer: 1,
    explanation:
      "The first operand (EAX) is the destination where the result is stored.",
  },
  {
    id: "CPE301_065",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What file extension is typically given to the Listing File?",
    options: [".exe", ".lst", ".obj", ".asm"],
    correctAnswer: 1,
    explanation: ".lst is the standard extension for listing files.",
  },
  {
    id: "CPE301_066",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which of the following statements creates a variable containing the carriage-return and line-feed characters?",
    options: ["BYTE 0Dh, 0Ah", "BYTE CR, LF", "BYTE '\\n'", "BYTE 13, 10"],
    correctAnswer: 0,
    explanation:
      "0Dh (13 decimal) is the Carriage Return and 0Ah (10 decimal) is the Line Feed. This hex notation is the standard form shown in MASM textbook examples for defining CR/LF bytes.",
  },
  {
    id: "CPE301_067",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: Identifier names in MASM are case-sensitive by default.",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation: "MASM is not case-sensitive by default (MOV is same as mov).",
  },
  {
    id: "CPE301_068",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If `list` is at offset 100, and `ListSize = ($ - list)`, what does `$` represent at that moment?",
    options: [
      "The offset 100",
      "The offset immediately following the array",
      "The total memory size",
      "0",
    ],
    correctAnswer: 1,
    explanation:
      "$ represents the current location counter, which would be the address immediately after the allocated array.",
  },
  {
    id: "CPE301_069",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which register is often used as an accumulator in arithmetic operations?",
    options: ["EIP", "ESP", "EAX", "EBP"],
    correctAnswer: 2,
    explanation: "EAX (Accumulator) is the primary register for arithmetic.",
  },
  {
    id: "CPE301_070",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Why might a programmer use the `TEXTEQU` directive?",
    options: [
      "To define a constant integer",
      "To create a text macro for code substitution",
      "To allocate memory for a string",
      "To define a floating point constant",
    ],
    correctAnswer: 1,
    explanation:
      "TEXTEQU creates text macros, allowing symbolic names for arbitrary text or code snippets.",
  },
  {
    id: "CPE301_071",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which operator would you use to define an array of 20 uninitialized BYTEs?",
    options: [
      "BYTE 20 DUP(?)",
      "BYTE 20 DUP(0)",
      "BYTE 20 ?",
      "BYTE ? DUP(20)",
    ],
    correctAnswer: 0,
    explanation:
      "DUP(?) creates uninitialized data. DUP(0) would initialize them to zero.",
  },
  {
    id: "CPE301_072",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the decimal value of the hex literal `0A3h`?",
    options: ["163", "103", "259", "10"],
    correctAnswer: 0,
    explanation: "A=10. 10*16 + 3 = 163.",
  },
  {
    id: "CPE301_073",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "The directive `.model flat` implies which type of memory addressing?",
    options: [
      "Segmented addressing",
      "Real-mode addressing",
      "Protected mode flat addressing",
      "Paged addressing only",
    ],
    correctAnswer: 2,
    explanation: ".model flat is standard for Win32 protected mode.",
  },
  {
    id: "CPE301_074",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which instruction pushes parameters onto the stack and calls a procedure in one line (in 32-bit MASM)?",
    options: ["CALL", "PUSH", "INVOKE", "RET"],
    correctAnswer: 2,
    explanation:
      "INVOKE is a high-level directive that handles pushing parameters and calling the function.",
  },
  {
    id: "CPE301_075",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What does the `IMUL` instruction do?",
    options: [
      "Integer Addition",
      "Integer Multiplication (Signed)",
      "Immediate Load",
      "Increment Multiplier",
    ],
    correctAnswer: 1,
    explanation: "IMUL performs signed integer multiplication.",
  },
  {
    id: "CPE301_076",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If `myList` is an array of DWORDs, what is the proper way to calculate its number of elements?",
    options: [
      "($ - myList)",
      "($ - myList) / 2",
      "($ - myList) / 4",
      "($ - myList) * 4",
    ],
    correctAnswer: 2,
    explanation: "Size in bytes divided by element size (4 bytes for DWORD).",
  },
  {
    id: "CPE301_077",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which character is used to indicate a comment in MASM?",
    options: ["//", "#", ";", "--"],
    correctAnswer: 2,
    explanation: "Semicolon (;) starts a single-line comment.",
  },
  {
    id: "CPE301_078",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: The `NOP` instruction is often used to align code to even address boundaries.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation: "True. It pads code to align addresses for performance.",
  },
  {
    id: "CPE301_079",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive defines a 48-bit integer (Far pointer)?",
    options: ["FWORD", "DWORD", "QWORD", "TBYTE"],
    correctAnswer: 0,
    explanation: "FWORD (Far Word) defines a 48-bit integer.",
  },
  {
    id: "CPE301_080",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the binary representation of the octal literal `42q`?",
    options: ["100010", "1000100", "01000010", "101010"],
    correctAnswer: 0,
    explanation: "Octal 4 = 100, Octal 2 = 010. Combined: 100010.",
  },
  {
    id: "CPE301_081",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which register contains the status flags (Zero, Carry, etc.)?",
    options: ["EAX", "ESP", "EFL (EFLAGS)", "EIP"],
    correctAnswer: 2,
    explanation: "EFL / EFLAGS register holds the status flags.",
  },
  {
    id: "CPE301_082",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "In the Listing File, bytes like `B8 00000005` represent:",
    options: [
      "The memory address",
      "The source code",
      "The machine code instructions",
      "The symbol table",
    ],
    correctAnswer: 2,
    explanation:
      "These are the hexadecimal representations of the machine instructions.",
  },
  {
    id: "CPE301_083",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which statement defines a constant `COUNT` equal to 500?",
    options: ["COUNT DWORD 500", "COUNT = 500", "COUNT: 500", "MOV COUNT, 500"],
    correctAnswer: 1,
    explanation:
      "COUNT = 500 defines a symbolic constant using the equal-sign directive.",
  },
  {
    id: "CPE301_084",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: The `INVOKE` directive is available in 64-bit MASM.",
    options: ["Maybe", "True", "I don't know", "False"],
    correctAnswer: 3,
    explanation: "False. 64-bit MASM does not support INVOKE.",
  },
  {
    id: "CPE301_085",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive defines a segment for uninitialized variables?",
    options: [".DATA", ".DATA?", ".CODE", ".STACK"],
    correctAnswer: 1,
    explanation: ".DATA? is specifically for uninitialized data.",
  },
  {
    id: "CPE301_086",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "In the instruction `mov eax, 5`, the value `5` is an example of:",
    options: [
      "A memory operand",
      "A register operand",
      "An immediate operand",
      "A direct operand",
    ],
    correctAnswer: 2,
    explanation:
      "A literal constant used as an operand is called an immediate operand.",
  },
  {
    id: "CPE301_087",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What does the suffix 'r' indicate in `3F800000r`?",
    options: ["Radix", "Register", "Encoded Real", "Rotated"],
    correctAnswer: 2,
    explanation:
      "The 'r' suffix indicates an encoded real (floating point) literal in hex.",
  },
  {
    id: "CPE301_088",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which of the following creates a block comment?",
    options: ["/* ... */", "COMMENT ! ... !", ";; ... ;;", "{ ... }"],
    correctAnswer: 1,
    explanation:
      "The COMMENT directive allows block comments with a user-defined delimiter (like !).",
  },
  {
    id: "CPE301_089",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If `myWord` is a WORD variable, how much is the address incremented to reach the next WORD in an array?",
    options: ["1", "2", "4", "8"],
    correctAnswer: 1,
    explanation: "A WORD is 2 bytes, so the address increments by 2.",
  },
  {
    id: "CPE301_090",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is a 'memory operand'?",
    options: [
      "A value stored in a register",
      "A constant literal",
      "A reference to a location in memory (variable)",
      "A stack pointer",
    ],
    correctAnswer: 2,
    explanation:
      "An operand that refers to data in memory (like a variable name) is a memory operand.",
  },
  {
    id: "CPE301_091",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive defines a 10-byte extended precision real?",
    options: ["REAL4", "REAL8", "REAL10", "REAL80"],
    correctAnswer: 2,
    explanation: "REAL10 defines a 10-byte (80-bit) extended real.",
  },
  {
    id: "CPE301_092",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: The assembler produces an Object File (.obj) that contains executable machine code ready to run.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation:
      "False. The object file must be LINKED to create an executable.",
  },
  {
    id: "CPE301_093",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive is used to specify the stack size?",
    options: [".SIZE", ".STACK", ".HEAP", ".MEM"],
    correctAnswer: 1,
    explanation: ".STACK <size> reserves stack space.",
  },
  {
    id: "CPE301_094",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the hexadecimal representation of the binary `1101b`?",
    options: ["Ah", "Bh", "Ch", "Dh"],
    correctAnswer: 3,
    explanation: "1101 = 8+4+0+1 = 13 = D in hex.",
  },
  {
    id: "CPE301_095",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which instruction adds a source operand to a destination operand?",
    options: ["SUM", "ADD", "PLUS", "INC"],
    correctAnswer: 1,
    explanation: "ADD is the mnemonic.",
  },
  {
    id: "CPE301_096",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the maximum number of characters in a MASM identifier?",
    options: ["32", "128", "247", "255"],
    correctAnswer: 2,
    explanation: "MASM identifiers may contain between 1 and 247 characters.",
  },
  {
    id: "CPE301_097",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive identifies the entry point of the program?",
    options: ["START", "END", "BEGIN", "MAIN"],
    correctAnswer: 1,
    explanation:
      "The END directive (e.g., `END main`) specifies the program entry point.",
  },
  {
    id: "CPE301_098",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "In 64-bit programming, pointers are how many bits wide?",
    options: ["16", "32", "64", "128"],
    correctAnswer: 2,
    explanation: "In 64-bit mode, addresses/pointers are 64 bits.",
  },
  {
    id: "CPE301_099",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: The `EQU` directive creates a symbol that uses no memory storage.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation:
      "True. EQU creates a symbolic constant replaced at compile time; it does not reserve memory.",
  },
  {
    id: "CPE301_100",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If `val1 DWORD 1`, what is the size of `val1`?",
    options: ["1 byte", "2 bytes", "4 bytes", "8 bytes"],
    correctAnswer: 2,
    explanation: "DWORD is 32 bits = 4 bytes.",
  },
  {
    id: "CPE301_101",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the effect of `myStr BYTE 20 DUP(0)`?",
    options: [
      "Allocates 20 bytes initialized to 0",
      "Allocates 20 bytes uninitialized",
      "Allocates 1 byte with value 20",
      "Allocates 20 words initialized to 0",
    ],
    correctAnswer: 0,
    explanation: "Allocates 20 bytes, each initialized to 0.",
  },
  {
    id: "CPE301_102",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which instruction is used to perform a 'no operation' cycle?",
    options: ["NULL", "VOID", "NOP", "SKIP"],
    correctAnswer: 2,
    explanation: "NOP (No Operation).",
  },
  {
    id: "CPE301_103",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which of the following is a legacy data directive for a 32-bit integer?",
    options: ["DB", "DW", "DD", "DQ"],
    correctAnswer: 2,
    explanation:
      "DD (Define Doubleword) is the legacy directive for 32-bit data.",
  },
  {
    id: "CPE301_104",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If you define `val1 REAL4 -1.2`, what type of data is this?",
    options: ["Integer", "String", "Floating-point", "BCD"],
    correctAnswer: 2,
    explanation: "REAL4 is a single-precision floating-point number.",
  },
  {
    id: "CPE301_105",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: The `EXITPROCESS` function must be called to properly terminate a Windows assembly program.",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation: "True. It returns control to the OS.",
  },
  {
    id: "CPE301_106",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which register is a 64-bit general purpose register?",
    options: ["EAX", "AX", "AL", "RAX"],
    correctAnswer: 3,
    explanation: "RAX is 64-bit. EAX is 32-bit. AX is 16-bit. AL is 8-bit.",
  },
  {
    id: "CPE301_107",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What does the `OFFSET` operator do?",
    options: [
      "Returns the value of a variable",
      "Returns the memory address (offset) of a variable",
      "Returns the size of a variable",
      "Returns the type of a variable",
    ],
    correctAnswer: 1,
    explanation:
      "OFFSET returns the distance of the variable from the beginning of its segment.",
  },
  {
    id: "CPE301_108",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "In `mov eax, [ebx]`, what type of operand is `[ebx]`?",
    options: ["Register", "Immediate", "Indirect Memory", "Direct Memory"],
    correctAnswer: 2,
    explanation:
      "Brackets indicate dereferencing (using the address in EBX), known as indirect memory addressing.",
  },
  {
    id: "CPE301_109",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive defines an 8-bit signed integer?",
    options: ["BYTE", "SBYTE", "UBYTE", "CHAR"],
    correctAnswer: 1,
    explanation: "SBYTE defines a signed byte.",
  },
  {
    id: "CPE301_110",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If `count = 500`, and you write `mov eax, count`, what code is generated?",
    options: [
      "mov eax, 500",
      "mov eax, count",
      "mov eax, [500]",
      "mov eax, offset count",
    ],
    correctAnswer: 0,
    explanation:
      "The `=` directive performs text substitution of the value. The code becomes `mov eax, 500`.",
  },
  {
    id: "CPE301_111",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which status flag indicates that the result of an operation is zero?",
    options: ["ZF", "CF", "SF", "OF"],
    correctAnswer: 0,
    explanation: "ZF (Zero Flag).",
  },
  {
    id: "CPE301_112",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the typical use of the `CDQ` instruction?",
    options: [
      "Convert Double to Quad",
      "Compare Double Quad",
      "Clear Data Queue",
      "Copy Data Quick",
    ],
    correctAnswer: 0,
    explanation:
      "CDQ extends the sign bit of EAX into EDX, converting a doubleword to a quadword (often for division).",
  },
  {
    id: "CPE301_113",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: `list BYTE 10, 20` defines two bytes at consecutive addresses.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation: "True. They are stored sequentially.",
  },
  {
    id: "CPE301_114",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What happens if you define `myStr BYTE 'A', 0, 'B'`?",
    options: [
      "It creates a string 'AB'",
      "It creates a null-terminated string 'A', followed by 'B'",
      "It creates a syntax error",
      "It creates 'A0B'",
    ],
    correctAnswer: 1,
    explanation:
      "The 0 terminates the first string. 'B' is just the next byte in memory.",
  },
  {
    id: "CPE301_115",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which assembler directive allows conditional assembly?",
    options: ["IF", "WHILE", "FOR", "COND"],
    correctAnswer: 0,
    explanation: "IF (and related directives) allow conditional assembly.",
  },
  {
    id: "CPE301_116",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the purpose of the `INCLUDE` directive?",
    options: [
      "To link a library",
      "To insert source code from another file into the current file",
      "To include comments",
      "To include binary resources",
    ],
    correctAnswer: 1,
    explanation: "INCLUDE textually inserts another file's content.",
  },
  {
    id: "CPE301_117",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If `myVal` is 1234h, and you `MOV AL, BYTE PTR myVal`, what is in AL?",
    options: ["12h", "34h", "1234h", "00h"],
    correctAnswer: 1,
    explanation:
      "Little-endian: 34h is at the lowest address. AL gets the low byte.",
  },
  {
    id: "CPE301_118",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive defines the memory model as flat?",
    options: [".386", ".MODEL FLAT", ".STACK", ".DATA"],
    correctAnswer: 1,
    explanation: ".MODEL FLAT specifies the flat memory model.",
  },
  {
    id: "CPE301_120",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: `main PROC` marks the start of the main procedure.",
    options: ["False", "Maybe", "True", "I don't know"],
    correctAnswer: 2,
    explanation: "True. PROC directives define the start of procedures.",
  },
  {
    id: "CPE301_121",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What does the instruction `INC EAX` do?",
    options: [
      "Increments EAX by 1",
      "Includes EAX",
      "Increments EAX by 2",
      "Initializes EAX",
    ],
    correctAnswer: 0,
    explanation: "INC increments the operand by 1.",
  },
  {
    id: "CPE301_122",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the result of `DEC` instruction?",
    options: ["Addition", "Subtraction by 1", "Division", "Declaration"],
    correctAnswer: 1,
    explanation: "DEC decrements (subtracts 1).",
  },
  {
    id: "CPE301_123",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive is used to define a stack of 1024 bytes?",
    options: [".STACK 1024", ".STACK 100h", ".MEM 1024", ".ALLOC 1024"],
    correctAnswer: 0,
    explanation: ".STACK directive takes the size in bytes.",
  },
  {
    id: "CPE301_124",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If `EAX` is 10, `ADD EAX, 5` results in:",
    options: ["10", "15", "5", "0"],
    correctAnswer: 1,
    explanation: "10 + 5 = 15.",
  },
  {
    id: "CPE301_125",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What does `SUB EAX, EBX` do?",
    options: [
      "EAX = EAX + EBX",
      "EAX = EAX - EBX",
      "EAX = EBX - EAX",
      "EBX = EBX - EAX",
    ],
    correctAnswer: 1,
    explanation: "Subtracts source (EBX) from destination (EAX).",
  },
  {
    id: "CPE301_126",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which of the following is an input-output instruction?",
    options: ["MOV", "IN", "ADD", "JMP"],
    correctAnswer: 1,
    explanation: "IN reads from a port. OUT writes to a port.",
  },
  {
    id: "CPE301_127",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: The assembler generates machine code for comments.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation: "False. Comments are ignored by the assembler.",
  },
  {
    id: "CPE301_128",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the purpose of the `NEG` instruction?",
    options: [
      "Negates (two's complement) a value",
      "Does nothing (No Operation)",
      "Next instruction",
      "Logical NOT",
    ],
    correctAnswer: 0,
    explanation: "NEG performs a Two's Complement negation (multiplies by -1).",
  },
  {
    id: "CPE301_129",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which instruction transfers control to a new location unconditionally?",
    options: ["JMP", "JE", "CALL", "RET"],
    correctAnswer: 0,
    explanation: "JMP (Jump) is an unconditional transfer.",
  },
  {
    id: "CPE301_130",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What does `JE` stand for?",
    options: ["Jump if Equal", "Jump if Error", "Jump if Empty", "Jump Every"],
    correctAnswer: 0,
    explanation: "Jump if Equal (conditional jump).",
  },
  {
    id: "CPE301_131",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which register is typically used as a loop counter?",
    options: ["ECX", "EDX", "EBX", "EAX"],
    correctAnswer: 0,
    explanation: "ECX (Counter register).",
  },
  {
    id: "CPE301_132",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is the machine code for `MOV EAX, 5` (approximate/concept)?",
    options: ["B8 05 00 00 00", "90", "CD 21", "E9 00 00"],
    correctAnswer: 0,
    explanation:
      "B8 is the opcode for MOV EAX, imm32. 05 00 00 00 is the value 5.",
  },
  {
    id: "CPE301_133",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: `val1 BYTE ?` leaves `val1` uninitialized (its value is undefined).",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 0,
    explanation:
      "True. The '?' initializer allocates space but does not set it to any specific value. The contents are undefined and will contain whatever was previously in that memory location.",
  },
  {
    id: "CPE301_134",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive defines an 80-bit integer?",
    options: ["REAL10", "TBYTE", "DQ", "OWORD"],
    correctAnswer: 1,
    explanation: "TBYTE is 80-bit.",
  },
  {
    id: "CPE301_135",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "If you have `array WORD 10 DUP(1)`, what is the total size in bytes?",
    options: ["10", "20", "30", "40"],
    correctAnswer: 1,
    explanation: "10 elements * 2 bytes/element = 20 bytes.",
  },
  {
    id: "CPE301_136",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What does the `$` operator return in a data definition?",
    options: [
      "The value of the variable",
      "The current offset address",
      "The size of the segment",
      "The stack pointer",
    ],
    correctAnswer: 1,
    explanation: "The current location counter ($) returns the current offset.",
  },
  {
    id: "CPE301_137",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which instruction pushes a value onto the stack?",
    options: ["POP", "PUSH", "MOV", "LOAD"],
    correctAnswer: 1,
    explanation: "PUSH adds to the stack.",
  },
  {
    id: "CPE301_138",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which instruction pops a value from the stack?",
    options: ["POP", "PUSH", "RET", "STORE"],
    correctAnswer: 0,
    explanation: "POP removes from the stack.",
  },
  {
    id: "CPE301_139",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: The stack grows downwards (towards lower addresses) on x86.",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation: "True. Pushing decrements the stack pointer.",
  },
  {
    id: "CPE301_140",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive defines a procedure?",
    options: ["PROC", "FUNC", "METHOD", "DEF"],
    correctAnswer: 0,
    explanation: "PROC defines a procedure.",
  },
  {
    id: "CPE301_141",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive ends a procedure?",
    options: ["ENDP", "END", "RET", "STOP"],
    correctAnswer: 0,
    explanation: "ENDP (End Procedure).",
  },
  {
    id: "CPE301_142",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What is `L1:` in the code `L1: MOV EAX, 0`?",
    options: ["A comment", "A code label", "A directive", "A variable"],
    correctAnswer: 1,
    explanation: "L1: is a code label.",
  },
  {
    id: "CPE301_143",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which instruction effectively does `Destination = Destination * Source`?",
    options: ["MUL", "IMUL", "DIV", "ADD"],
    correctAnswer: 1,
    explanation:
      "IMUL (Signed Multiply) can take operands. MUL typically uses implicit operands.",
  },
  {
    id: "CPE301_144",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: `MOV` can move memory to memory.",
    options: ["False", "Maybe", "True", "I don't know"],
    correctAnswer: 0,
    explanation:
      "False. x86 MOV cannot move memory to memory directly; you must go through a register.",
  },
  {
    id: "CPE301_146",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What represents the `Extended Instruction Pointer`?",
    options: ["EAX", "ESP", "EIP", "EBP"],
    correctAnswer: 2,
    explanation: "EIP is the instruction pointer.",
  },
  {
    id: "CPE301_147",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "What does `OFFSET var` return?",
    options: [
      "The value of var",
      "The size of var",
      "The address of var",
      "The type of var",
    ],
    correctAnswer: 2,
    explanation: "It returns the offset address.",
  },
  {
    id: "CPE301_148",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which type of operand is `100` in `MOV EAX, 100`?",
    options: ["Register", "Immediate", "Memory", "Direct"],
    correctAnswer: 1,
    explanation: "100 is an immediate value.",
  },
  {
    id: "CPE301_149",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "True or False: `REAL4` is 32 bits.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation: "True. 4 bytes = 32 bits.",
  },
  {
    id: "CPE301_150",
    course: "CPE301",
    chapter: "Chapter 3",
    text: "Which directive defines a quadword (64 bits)?",
    options: ["DQ", "DD", "DW", "DB"],
    correctAnswer: 0,
    explanation: "DQ (Define Quadword).",
  },
];

export default cpe301Chapter3;
