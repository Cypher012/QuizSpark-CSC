import { QuestionV2 } from "@/lib/quiz-types";

const cpe301Chapter4: QuestionV2[] = [
  // SECTION 4.1: Data Transfer Instructions
  {
    id: "cpe301_001",
    course: "CPE 301",
    chapter: "Chapter 4",
    text: "Which of the following is NOT a basic type of operand in x86 assembly?",
    options: ["Immediate", "Register", "Memory", "Floating-point stack"],
    correctAnswer: 3,
    explanation:
      "The text identifies three basic types of operands: Immediate, Register, and Memory. While floating-point operations exist, 'Floating-point stack' is not listed as one of the three basic operand types in the context of data transfer instructions.",
  },
  {
    id: "cpe301_002",
    course: "CPE 301",
    chapter: "Chapter 4",
    text: "Which instruction is used to move data from a source operand to a destination operand?",
    options: ["CPY", "MOV", "XCHG", "LEA"],
    correctAnswer: 1,
    explanation:
      "The MOV instruction copies data from a source operand to a destination operand.",
  },
  {
    id: "cpe301_003",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In the instruction `MOV destination, source`, what happens to the source operand?",
    options: [
      "It is cleared to zero.",
      "It is moved to the destination and then deleted.",
      "It remains unchanged.",
      "It is incremented by 1.",
    ],
    correctAnswer: 2,
    explanation:
      "The MOV instruction copies data; the source operand remains unchanged.",
  },
  {
    id: "cpe301_004",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which of the following MOV instruction formats is INVALID?",
    options: ["MOV reg, reg", "MOV mem, imm", "MOV mem, mem", "MOV reg, mem"],
    correctAnswer: 2,
    explanation:
      "A single MOV instruction cannot be used to move data directly from one memory location to another (memory-to-memory transfers are not allowed).",
  },
  {
    id: "cpe301_005",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: The destination operand of a MOV instruction cannot be the instruction pointer (EIP).",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation:
      "The instruction pointer register (IP, EIP, or RIP) cannot be a destination operand for a MOV instruction.",
  },
  {
    id: "cpe301_006",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is the purpose of the MOVZX instruction?",
    options: [
      "Move with zero-extend",
      "Move with sign-extend",
      "Move and exchange",
      "Move zero to register",
    ],
    correctAnswer: 0,
    explanation:
      "MOVZX stands for 'move with zero-extend'. It copies a source operand to a destination operand and zero-extends the value.",
  },
  {
    id: "cpe301_007",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "When using MOVZX, which type of integer is it typically used with?",
    options: [
      "Signed integers only",
      "Unsigned integers only",
      "Floating-point numbers",
      "Both signed and unsigned integers",
    ],
    correctAnswer: 1,
    explanation: "MOVZX is only used with unsigned integers.",
  },
  {
    id: "cpe301_008",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction should be used to move a signed integer to a larger destination operand while preserving its sign?",
    options: ["MOV", "MOVZX", "MOVSX", "XCHG"],
    correctAnswer: 2,
    explanation:
      "MOVSX (move with sign-extend) copies a signed integer to a larger destination and fills the upper bits with a copy of the source's sign bit.",
  },
  {
    id: "cpe301_009",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "The LAHF instruction copies the low byte of which register into AH?",
    options: ["EAX", "EBX", "EFLAGS", "ECX"],
    correctAnswer: 2,
    explanation: "LAHF copies the low byte of the EFLAGS register into AH.",
  },
  {
    id: "cpe301_010",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction exchanges the contents of two operands?",
    options: ["SWAP", "XCHG", "MOV", "SWITCH"],
    correctAnswer: 1,
    explanation:
      "The XCHG (exchange data) instruction exchanges the contents of two operands.",
  },
  {
    id: "cpe301_011",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which of the following is NOT a valid operand combination for XCHG?",
    options: [
      "XCHG reg, reg",
      "XCHG reg, mem",
      "XCHG mem, reg",
      "XCHG mem, imm",
    ],
    correctAnswer: 3,
    explanation: "The XCHG instruction does not accept immediate operands.",
  },
  {
    id: "cpe301_012",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `arrayB` is a byte array at offset 100h, what is the value of `AL` after `MOV AL, [arrayB+2]` if the array contains `10h, 20h, 30h`?",
    options: ["10h", "20h", "30h", "Undefined"],
    correctAnswer: 2,
    explanation:
      "`arrayB+2` points to the third element (index 2). If elements are 10h, 20h, 30h, the third element is 30h.",
  },
  {
    id: "cpe301_013",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: MASM automatically checks for array bounds violations when using direct-offset operands.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 2,
    explanation:
      "MASM has no built-in range checking for effective addresses. Accessing memory outside the array is possible and can cause bugs.",
  },
  {
    id: "cpe301_014",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In an array of 16-bit words, if the first element is at offset 100h, what is the offset of the second element?",
    options: ["101h", "102h", "104h", "108h"],
    correctAnswer: 1,
    explanation:
      "Each element in a word array is 2 bytes long. 100h + 2 = 102h.",
  },
  {
    id: "cpe301_015",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "To move a 32-bit doubleword from an array `arrayD` to EAX, accessing the second element, which instruction is correct?",
    options: [
      "MOV EAX, [arrayD+1]",
      "MOV EAX, [arrayD+2]",
      "MOV EAX, [arrayD+4]",
      "MOV EAX, [arrayD+8]",
    ],
    correctAnswer: 2,
    explanation:
      "Doublewords are 4 bytes. The second element is at offset +4 bytes from the start.",
  },
  {
    id: "cpe301_016",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction does NOT affect the Carry flag?",
    options: ["ADD", "SUB", "INC", "NEG"],
    correctAnswer: 2,
    explanation:
      "The INC (increment) and DEC (decrement) instructions do not affect the Carry flag.",
  },
  {
    id: "cpe301_017",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What does the INC instruction do?",
    options: [
      "Includes a library",
      "Increments an operand by 1",
      "Increments an operand by 2",
      "Initializes a counter",
    ],
    correctAnswer: 1,
    explanation: "INC (increment) adds 1 to a register or memory operand.",
  },
  {
    id: "cpe301_018",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `AL` contains `FFh`, what is the value of `AL` and the Zero Flag (ZF) after `INC AL`?",
    options: ["AL=00h, ZF=0", "AL=00h, ZF=1", "AL=FFh, ZF=1", "AL=01h, ZF=0"],
    correctAnswer: 1,
    explanation:
      "FFh + 1 = 100h. Stored in 8 bits, it becomes 00h. Since the result is zero, ZF is set to 1.",
  },
  {
    id: "cpe301_019",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "The NEG instruction performs what operation?",
    options: [
      "One's complement",
      "Two's complement",
      "Sets the sign bit to 1",
      "Subtracts 1",
    ],
    correctAnswer: 1,
    explanation:
      "NEG reverses the sign of a number by converting it to its two's complement (invert bits + 1).",
  },
  {
    id: "cpe301_020",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "When adding two unsigned integers, which flag signals if the result is too large for the destination operand?",
    options: [
      "Overflow Flag (OF)",
      "Sign Flag (SF)",
      "Carry Flag (CF)",
      "Zero Flag (ZF)",
    ],
    correctAnswer: 2,
    explanation: "The Carry Flag (CF) indicates unsigned integer overflow.",
  },
  {
    id: "cpe301_021",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "When adding two signed integers, which flag signals if the result is too large (positive or negative) for the destination?",
    options: [
      "Overflow Flag (OF)",
      "Sign Flag (SF)",
      "Carry Flag (CF)",
      "Parity Flag (PF)",
    ],
    correctAnswer: 0,
    explanation: "The Overflow Flag (OF) indicates signed integer overflow.",
  },
  {
    id: "cpe301_022",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What does the Zero Flag (ZF) indicate?",
    options: [
      "The destination operand is zero.",
      "The result of an arithmetic operation is zero.",
      "The carry flag is zero.",
      "The operation was invalid.",
    ],
    correctAnswer: 1,
    explanation:
      "The Zero flag is set when the result of an arithmetic operation equals zero.",
  },
  {
    id: "cpe301_023",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: Subtracting a larger unsigned integer from a smaller one sets the Carry Flag.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation:
      "A subtract operation sets the Carry flag when a larger unsigned integer is subtracted from a smaller one (a borrow occurs).",
  },
  {
    id: "cpe301_024",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "The Parity Flag (PF) is set when the least significant byte of the destination has:",
    options: [
      "An odd number of 1 bits",
      "An even number of 1 bits",
      "A value of zero",
      "A negative value",
    ],
    correctAnswer: 1,
    explanation:
      "The Parity flag is set when the least significant byte of the destination has an even number of 1 bits.",
  },
  {
    id: "cpe301_025",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What happens if you try to `NEG` the value -128 in an 8-bit register (AL)?",
    options: [
      "AL becomes +128",
      "AL becomes 0",
      "The Overflow Flag (OF) is set",
      "The Sign Flag (SF) is cleared",
    ],
    correctAnswer: 2,
    explanation:
      "+128 cannot be represented in a signed 8-bit integer (range -128 to +127). The operation is invalid, so the Overflow Flag is set.",
  },

  // SECTION 4.3: Data-Related Operators and Directives
  {
    id: "cpe301_026",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What does the OFFSET operator return?",
    options: [
      "The value stored at a variable's address",
      "The distance of a variable from the beginning of its enclosing segment",
      "The size of the variable in bytes",
      "The type of the variable",
    ],
    correctAnswer: 1,
    explanation:
      "The OFFSET operator returns the distance (in bytes) of a label from the beginning of its enclosing segment.",
  },
  {
    id: "cpe301_027",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which directive aligns a variable on a byte, word, doubleword, or paragraph boundary?",
    options: ["OFFSET", "ALIGN", "PTR", "TYPE"],
    correctAnswer: 1,
    explanation:
      "The ALIGN directive aligns a variable on a specified boundary (e.g., ALIGN 2, ALIGN 4).",
  },
  {
    id: "cpe301_028",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Why is data alignment important?",
    options: [
      "It saves memory space.",
      "It makes the code easier to read.",
      "The CPU can process aligned data more quickly.",
      "It is required by the operating system.",
    ],
    correctAnswer: 2,
    explanation:
      "The CPU can process data stored at even-numbered (aligned) addresses more quickly than at odd-numbered addresses.",
  },
  {
    id: "cpe301_029",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is the purpose of the PTR operator?",
    options: [
      "To return a pointer to a variable",
      "To override the declared size of an operand",
      "To calculate the size of an array",
      "To align data in memory",
    ],
    correctAnswer: 1,
    explanation:
      "PTR is used to override an operand's default size (e.g., treating a DWORD variable as a WORD).",
  },
  {
    id: "cpe301_030",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `myDouble` is a DWORD variable, how would you move its lower 16 bits into AX?",
    options: [
      "MOV AX, myDouble",
      "MOV AX, WORD PTR myDouble",
      "MOV AX, OFFSET myDouble",
      "MOV AX, TYPE myDouble",
    ],
    correctAnswer: 1,
    explanation:
      "You must use `WORD PTR` to tell the assembler to treat the DWORD variable as a WORD for this instruction.",
  },
  {
    id: "cpe301_031",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What value does the TYPE operator return for a DWORD variable?",
    options: ["1", "2", "4", "8"],
    correctAnswer: 2,
    explanation: "A DWORD (Doubleword) is 4 bytes, so TYPE returns 4.",
  },
  {
    id: "cpe301_032",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What does the LENGTHOF operator return?",
    options: [
      "The number of bytes in an array",
      "The number of elements in an array",
      "The size of a single element",
      "The address of the last element",
    ],
    correctAnswer: 1,
    explanation: "LENGTHOF counts the number of elements in an array.",
  },
  {
    id: "cpe301_033",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What does the SIZEOF operator return?",
    options: [
      "LENGTHOF + TYPE",
      "LENGTHOF / TYPE",
      "LENGTHOF * TYPE",
      "LENGTHOF - TYPE",
    ],
    correctAnswer: 2,
    explanation:
      "SIZEOF returns the total number of bytes used by an array initializer, which is equivalent to LENGTHOF multiplied by TYPE.",
  },
  {
    id: "cpe301_034",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which directive allows you to insert a label and give it a size attribute without allocating storage?",
    options: ["LABEL", "ALIGN", "PTR", "OFFSET"],
    correctAnswer: 0,
    explanation:
      "The LABEL directive inserts a label with a size attribute (like BYTE or WORD) but allocates no storage.",
  },
  {
    id: "cpe301_035",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: `mov esi, OFFSET myArray + 4` points ESI to the beginning of the array plus 4 bytes.",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation:
      "OFFSET returns the base address, and + 4 adds 4 bytes to that address.",
  },

  // SECTION 4.4: Indirect Addressing
  {
    id: "cpe301_036",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is indirect addressing?",
    options: [
      "Using a constant offset to access memory",
      "Using a register as a pointer to access memory",
      "Using immediate values directly",
      "Moving data between registers",
    ],
    correctAnswer: 1,
    explanation:
      "Indirect addressing uses a register (like ESI) to hold the address of the data, acting as a pointer.",
  },
  {
    id: "cpe301_037",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which notation correctly represents an indirect operand?",
    options: ["ESI", "[ESI]", "OFFSET ESI", "PTR ESI"],
    correctAnswer: 1,
    explanation:
      "Brackets around a register (e.g., [ESI]) indicate that the register holds an address and should be dereferenced.",
  },
  {
    id: "cpe301_038",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Why does `inc [esi]` cause an assembler error?",
    options: [
      "ESI cannot be used for indirect addressing.",
      "INC cannot operate on memory.",
      "The operand size is ambiguous (byte, word, etc.?).",
      "Brackets are not allowed with INC.",
    ],
    correctAnswer: 2,
    explanation:
      "The assembler doesn't know if [esi] points to a byte, word, or doubleword. You must use `inc BYTE PTR [esi]` or similar.",
  },
  {
    id: "cpe301_039",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If ESI points to the start of a WORD array, how much should you add to ESI to point to the next element?",
    options: ["1", "2", "4", "8"],
    correctAnswer: 1,
    explanation:
      "A WORD is 2 bytes, so you must add 2 to the pointer to reach the next element.",
  },
  {
    id: "cpe301_040",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is an indexed operand?",
    options: [
      "An operand that uses a constant only.",
      "An operand that adds a constant to a register to generate an effective address.",
      "An operand that uses the stack pointer.",
      "An operand that cannot be used for arrays.",
    ],
    correctAnswer: 1,
    explanation:
      "An indexed operand combines a register with a constant (e.g., `array[esi]` or `[array + esi]`) to calculate an address.",
  },
  {
    id: "cpe301_041",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: In 32-bit mode, any general-purpose 32-bit register can be used as an index register.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 0,
    explanation:
      "Any 32-bit general-purpose register (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP) can be used.",
  },
  {
    id: "cpe301_042",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is a scale factor in indexed operands?",
    options: [
      "A multiplier used to calculate array offsets based on element size.",
      "A value added to the final result.",
      "The number of elements in the array.",
      "The maximum size of the array.",
    ],
    correctAnswer: 0,
    explanation:
      "The scale factor (1, 2, 4, or 8) is multiplied by the index to automatically handle element sizes (e.g., `[esi*4]`).",
  },
  {
    id: "cpe301_043",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction demonstrates using a scale factor for a doubleword array?",
    options: [
      "MOV EAX, arrayD[ESI*2]",
      "MOV EAX, arrayD[ESI*4]",
      "MOV EAX, arrayD[ESI*8]",
      "MOV EAX, arrayD[ESI*1]",
    ],
    correctAnswer: 1,
    explanation: "Doublewords are 4 bytes, so the scale factor must be 4.",
  },
  {
    id: "cpe301_044",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is a pointer variable?",
    options: [
      "A variable that holds a constant.",
      "A variable that contains the address of another variable.",
      "A variable that cannot be changed.",
      "A register used for arithmetic.",
    ],
    correctAnswer: 1,
    explanation: "A pointer is a variable that stores a memory address.",
  },
  {
    id: "cpe301_045",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What does the TYPEDEF operator do?",
    options: [
      "Defines a new variable.",
      "Creates a user-defined type.",
      "Calculates the type of an operand.",
      "Changes the type of an existing variable.",
    ],
    correctAnswer: 1,
    explanation:
      "TYPEDEF allows you to create a user-defined type (often for pointers) that acts like a built-in type.",
  },

  // SECTION 4.5: JMP and LOOP Instructions
  {
    id: "cpe301_046",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction creates an unconditional transfer of control?",
    options: ["LOOP", "MOV", "JMP", "CMP"],
    correctAnswer: 2,
    explanation:
      "The JMP (Jump) instruction unconditionally transfers control to a new location.",
  },
  {
    id: "cpe301_047",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which register is automatically used as the counter for the LOOP instruction in 32-bit mode?",
    options: ["EAX", "EBX", "ECX", "EDX"],
    correctAnswer: 2,
    explanation: "ECX is the default loop counter for the LOOP instruction.",
  },
  {
    id: "cpe301_048",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What logic does the LOOP instruction perform?",
    options: [
      "Increments ECX; if ECX != 0, jump.",
      "Decrements ECX; if ECX != 0, jump.",
      "Compares ECX to 0; if equal, jump.",
      "Decrements ECX; if ECX == 0, jump.",
    ],
    correctAnswer: 1,
    explanation:
      "LOOP first decrements ECX, then checks if ECX is not zero. If it's not zero, it jumps to the target label.",
  },
  {
    id: "cpe301_049",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If ECX is initialized to 0 before a LOOP instruction, how many times will the loop execute?",
    options: ["0 times", "1 time", "4,294,967,296 times", "Infinite times"],
    correctAnswer: 2,
    explanation:
      "LOOP decrements 0 to FFFFFFFFh (-1), so it will repeat 2^32 (4 billion+) times before reaching 0 again.",
  },
  {
    id: "cpe301_050",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: You should explicitly modify the ECX register inside a loop that uses the LOOP instruction.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation:
      "Modifying ECX inside a LOOP structure interferes with the loop logic and usually causes logic errors (like infinite loops).",
  },

  // Mixed Application / Review Questions
  {
    id: "cpe301_051",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction does not require both operands to be the same size?",
    options: ["MOV", "ADD", "MOVZX", "SUB"],
    correctAnswer: 2,
    explanation:
      "MOVZX (and MOVSX) is designed to move a smaller source operand to a larger destination operand.",
  },
  {
    id: "cpe301_052",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In the context of the LOOP instruction, what happens if the destination label is too far away?",
    options: [
      "The assembler automatically switches to a far jump.",
      "The program crashes at runtime.",
      "The assembler generates an error.",
      "The loop executes only once.",
    ],
    correctAnswer: 2,
    explanation:
      "The LOOP destination must be within -128 to +127 bytes. If it's too far, MASM generates a 'jump destination too far' error.",
  },
  {
    id: "cpe301_053",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "How do you define a nested loop correctly using ECX?",
    options: [
      "Use the same ECX counter for both loops.",
      "Push ECX to stack (or save to variable) before inner loop, pop/restore after.",
      "Use EDX for the inner loop.",
      "You cannot nest LOOP instructions.",
    ],
    correctAnswer: 1,
    explanation:
      "Since LOOP always uses ECX, you must save the outer loop's count before the inner loop and restore it afterwards.",
  },
  {
    id: "cpe301_054",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "To copy a string using a loop, which register is typically used for indexed addressing?",
    options: ["ESP", "EIP", "ESI", "EBP"],
    correctAnswer: 2,
    explanation:
      "ESI (Source Index) is commonly used as an index register for arrays and strings.",
  },
  {
    id: "cpe301_055",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which flag corresponds to the symbol 'OV' in the Visual Studio debugger?",
    options: ["Zero Flag", "Overflow Flag", "Sign Flag", "Direction Flag"],
    correctAnswer: 1,
    explanation: "OV stands for Overflow.",
  },
  {
    id: "cpe301_056",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is the value of the Parity Flag if the result low byte has an odd number of 1 bits?",
    options: ["1 (Set)", "0 (Clear)", "Undefined", "Depends on the Carry Flag"],
    correctAnswer: 1,
    explanation:
      "The Parity Flag is set (1) if there is an *even* number of 1 bits. It is clear (0) for an odd number.",
  },
  {
    id: "cpe301_057",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: The Auxiliary Carry flag is primarily used for BCD (Binary Coded Decimal) arithmetic.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 0,
    explanation:
      "The AC flag tracks carries out of bit 3, which is used for BCD correction.",
  },
  {
    id: "cpe301_058",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "When translating `Rval = -Xval + (Yval - Zval)` to assembly, which operation is performed first for `-Xval`?",
    options: ["SUB", "MOV", "NEG", "ADD"],
    correctAnswer: 1,
    explanation:
      "Typically, `MOV` is used to copy the variable to a register before applying `NEG`.",
  },
  {
    id: "cpe301_059",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which operand type uses a numeric literal expression?",
    options: ["Register", "Memory", "Immediate", "Direct"],
    correctAnswer: 2,
    explanation:
      "An immediate operand is a constant value (literal) encoded directly into the instruction.",
  },
  {
    id: "cpe301_060",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If you want to move the value 0 into EAX, which instruction is valid?",
    options: ["MOV 0, EAX", "MOV EAX, 0", "MOV [EAX], 0", "MOV EAX, ZERO"],
    correctAnswer: 1,
    explanation:
      "MOV destination, source. EAX is the destination, 0 is the immediate source.",
  },
  {
    id: "cpe301_061",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In the instruction `mov al, [arrayB + 1]`, what is `[arrayB + 1]` called?",
    options: [
      "Immediate operand",
      "Register operand",
      "Effective address",
      "Direct-offset operand",
    ],
    correctAnswer: 3,
    explanation:
      "It adds a displacement (1) to a variable name, creating a direct-offset operand.",
  },
  {
    id: "cpe301_062",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: The SAHF instruction copies the Status Flags into the AH register.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation:
      "False. SAHF stores AH *into* the status flags. LAHF loads flags *into* AH.",
  },
  {
    id: "cpe301_063",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `myWord` is at offset 0000 and contains 1234h, what does `mov al, BYTE PTR myWord` put in AL?",
    options: ["12h", "34h", "00h", "Error"],
    correctAnswer: 1,
    explanation:
      "x86 is Little Endian. The low byte (34h) is stored at the lower address (offset 0000).",
  },
  {
    id: "cpe301_064",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is the result of `LENGTHOF` on an array defined as `array1 WORD 30 DUP(?), 0, 0`?",
    options: ["30", "32", "64", "60"],
    correctAnswer: 1,
    explanation:
      "30 elements from DUP plus 2 explicitly defined elements (0, 0) = 32 elements.",
  },
  {
    id: "CPE301_065",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction does NOT support immediate operands?",
    options: ["MOV", "ADD", "SUB", "XCHG"],
    correctAnswer: 3,
    explanation:
      "XCHG exchanges two writable locations (register/memory). It cannot exchange with a constant (immediate).",
  },
  {
    id: "cpe301_066",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What happens if you add 1 to a byte variable containing 255 (FFh)?",
    options: [
      "It becomes 256",
      "It wraps to 0 and sets the Carry Flag",
      "It wraps to 0 and sets the Overflow Flag",
      "It remains 255",
    ],
    correctAnswer: 1,
    explanation:
      "FFh + 1 = 100h. This fits in 9 bits. The lower 8 bits (00) are stored, and the 9th bit becomes the Carry Flag.",
  },
  {
    id: "cpe301_067",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: `ALIGN 2` ensures the next variable starts at an address divisible by 2.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation: "ALIGN 2 aligns to a word boundary (even address).",
  },
  {
    id: "cpe301_068",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In 64-bit mode, what is the size of the default operand for MOV?",
    options: ["16 bits", "32 bits", "64 bits", "Variable"],
    correctAnswer: 1,
    explanation:
      "While 64-bit mode supports 64-bit data, the default operand size for many instructions remains 32 bits for compatibility and code density, though R-registers are 64-bit. (Note: The prompt asks for 64-bit programming section, but based on general x86-64, 32-bit is often default for immediates, but registers like RAX are 64-bit. In the context of the book's 32-bit focus with a 64-bit section, usually 32-bit is standard unless R-prefix is used.)",
  },
  {
    id: "cpe301_069",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction allows a loop to execute a specific number of times?",
    options: ["JMP", "LOOP", "REP", "CALL"],
    correctAnswer: 1,
    explanation: "LOOP repeats a block based on the ECX counter.",
  },
  {
    id: "cpe301_070",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is the primary difference between a JMP and a LOOP instruction?",
    options: [
      "JMP is conditional; LOOP is unconditional.",
      "JMP is unconditional; LOOP is conditional based on ECX.",
      "JMP uses a counter; LOOP does not.",
      "They are identical.",
    ],
    correctAnswer: 1,
    explanation:
      "JMP always jumps. LOOP jumps only if ECX != 0 after decrementing.",
  },
  {
    id: "cpe301_071",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If you need to access the 5th element of a DWORD array named `list`, what is the offset from the start?",
    options: ["5", "10", "16", "20"],
    correctAnswer: 2,
    explanation: "Index 4 (5th element). 4 * 4 bytes/element = 16 bytes.",
  },
  {
    id: "cpe301_072",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which register is best suited for string source indexing?",
    options: ["EDI", "ESI", "EBP", "ESP"],
    correctAnswer: 1,
    explanation:
      "ESI (Extended Source Index) is conventionally used for source data.",
  },
  {
    id: "cpe301_073",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: `OFFSET` is determined at runtime.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 2,
    explanation:
      "OFFSET is an assembler operator determined at assembly/link time, not runtime.",
  },
  {
    id: "cpe301_074",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What does `mov eax, [ebx+esi]` represent?",
    options: [
      "Indirect addressing",
      "Indexed addressing",
      "Based-indexed addressing",
      "Immediate addressing",
    ],
    correctAnswer: 2,
    explanation:
      "It uses a base register (EBX) and an index register (ESI), known as based-indexed addressing.",
  },
  {
    id: "cpe301_075",
    course: "CPE 301",
    chapter: "Chapter 4",
    text: "If AL contains +127 and you execute `add al, 1`, which flag is SET?",
    options: ["Carry Flag", "Zero Flag", "Overflow Flag", "Parity Flag"],
    correctAnswer: 2,
    explanation:
      "Signed overflow occurs: +127 + 1 = +128, which cannot fit in a signed byte (max +127). It wraps to -128, setting OF.",
  },
  // SECTION 4.6: 64-Bit Programming
  {
    id: "cpe301_076",
    course: "CPE 301",
    chapter: "Chapter 4",
    text: "In 64-bit mode, what happens to the upper 32 bits of a 64-bit destination register when a 32-bit constant is moved into its lower 32 bits?",
    options: [
      "They are preserved.",
      "They are cleared (set to zero).",
      "They are set to all ones.",
      "They become undefined.",
    ],
    correctAnswer: 1,
    explanation:
      "When you move a 32-bit constant to a 64-bit register, the upper 32 bits of the destination are cleared.",
  },
  {
    id: "cpe301_077",
    course: "CPE 301",
    chapter: "Chapter 4",
    text: "True or False: Moving an 8-bit or 16-bit memory operand into the lower part of a 64-bit register clears the upper bits of the register.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 2,
    explanation:
      "Moving an 8-bit or 16-bit memory operand into the lower bits of a 64-bit register does NOT affect the upper bits.",
  },
  {
    id: "cpe301_078",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction allows moving a 32-bit source operand into a 64-bit destination with sign extension?",
    options: ["MOVZX", "MOVSXD", "MOV", "XCHG"],
    correctAnswer: 1,
    explanation:
      "The MOVSXD instruction (move with sign-extension) permits the source operand to be a 32-bit register or memory operand and sign-extends it to 64 bits.",
  },
  {
    id: "cpe301_079",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which register is used as the loop counter for the LOOP instruction in 64-bit mode?",
    options: ["ECX", "CX", "RCX", "RDX"],
    correctAnswer: 2,
    explanation:
      "The LOOP instruction in 64-bit mode uses the RCX register as the loop counter.",
  },
  {
    id: "cpe301_080",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In 64-bit mode, what size is the address generated by the OFFSET operator?",
    options: ["16 bits", "32 bits", "64 bits", "Variable"],
    correctAnswer: 2,
    explanation:
      "The OFFSET operator generates a 64-bit address in 64-bit mode, which must be held by a 64-bit register.",
  },
  {
    id: "cpe301_081",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What data type directive is used to create an array of 64-bit integers?",
    options: ["DWORD", "QWORD", "TBYTE", "OWORD"],
    correctAnswer: 1,
    explanation:
      "QWORD (Quadword) allocates storage for 64-bit (8-byte) values.",
  },
  {
    id: "cpe301_082",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "When adding 1 to the 32-bit register EAX in 64-bit mode, how are the upper 32 bits of RAX affected?",
    options: [
      "They are cleared.",
      "They are incremented if a carry occurs.",
      "They are not modified.",
      "They become undefined.",
    ],
    correctAnswer: 2,
    explanation:
      "When you use a partial register operand (like EAX), the remainder of the register (upper RAX) is not modified (except for the special case of MOV 32-bit to 64-bit reg).",
  },
  {
    id: "cpe301_083",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What scale factor should be used for indexed operands when accessing an array of 64-bit integers?",
    options: ["2", "4", "8", "16"],
    correctAnswer: 2,
    explanation:
      "Since 64-bit integers are 8 bytes long, a scale factor of 8 is used (e.g., `[rsi*8]`).",
  },
  {
    id: "cpe301_084",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: In 64-bit mode, immediate operands can be 64 bits long.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation:
      "Immediate operands (constants) may be 8, 16, 32, or 64 bits in 64-bit mode.",
  },
  {
    id: "cpe301_085",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What happens if you execute `MOV RAX, FFFFFFFFh` in 64-bit mode?",
    options: [
      "RAX = FFFFFFFF00000000h",
      "RAX = 00000000FFFFFFFFh",
      "RAX = FFFFFFFFFFFFFFFFh",
      "Assembler error",
    ],
    correctAnswer: 1,
    explanation:
      "Moving a 32-bit constant into a 64-bit register clears the upper 32 bits.",
  },

  // MIXED / COMPREHENSIVE QUESTIONS (Continuing Coverage)
  {
    id: "cpe301_086",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In the `SumArray` program (32-bit), which instruction points to the next element in the array?",
    options: [
      "INC EDI",
      "ADD EDI, 1",
      "ADD EDI, TYPE intarray",
      "ADD EDI, SIZEOF intarray",
    ],
    correctAnswer: 2,
    explanation:
      "To point to the next element, you add the size of a single element (TYPE) to the index register.",
  },
  {
    id: "cpe301_087",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction format allows adding a 32-bit integer constant to a 64-bit register in 64-bit mode?",
    options: [
      "ADD reg64, imm32",
      "ADD reg32, imm64",
      "ADD mem64, imm64",
      "ADD reg64, mem32",
    ],
    correctAnswer: 0,
    explanation:
      "Standard ADD instruction supports adding an immediate 32-bit value to a 64-bit register (e.g., `ADD RAX, 1`).",
  },
  {
    id: "cpe301_088",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `myArray` is a WORD array, what is the value of `TYPE myArray`?",
    options: ["1", "2", "4", "8"],
    correctAnswer: 1,
    explanation: "The TYPE of a WORD (16-bit) is 2 bytes.",
  },
  {
    id: "cpe301_089",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which operator would you use to calculate the number of elements in an array defined with nested DUP operators?",
    options: ["SIZEOF", "LENGTHOF", "TYPE", "OFFSET"],
    correctAnswer: 1,
    explanation:
      "LENGTHOF returns the total number of elements in an array, handling nested DUPs.",
  },
  {
    id: "cpe301_090",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: The `LABEL` directive allocates memory storage for a variable.",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation:
      "The LABEL directive inserts a label and gives it a size attribute but does NOT allocate any storage.",
  },
  {
    id: "cpe301_091",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is the purpose of the `ALIGN 4` directive?",
    options: [
      "To align the next variable on a 4-bit boundary.",
      "To align the next variable on a 4-byte (doubleword) boundary.",
      "To add 4 to the current offset.",
      "To reserve 4 bytes of storage.",
    ],
    correctAnswer: 1,
    explanation:
      "ALIGN 4 aligns the next address to a multiple of 4 (doubleword boundary).",
  },
  {
    id: "cpe301_092",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `val32` is a DWORD containing `12345678h`, what is the value moved to AX by `MOV AX, WORD PTR val32`?",
    options: ["1234h", "5678h", "12345678h", "0000h"],
    correctAnswer: 1,
    explanation:
      "In Little Endian, the lower word (5678h) is at the starting address.",
  },
  {
    id: "cpe301_093",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which directive creates a user-defined type for a pointer?",
    options: ["STRUCT", "UNION", "TYPEDEF", "MACRO"],
    correctAnswer: 2,
    explanation:
      "TYPEDEF allows creating user-defined types, often used for pointers (e.g., `PBYTE TYPEDEF PTR BYTE`).",
  },
  {
    id: "cpe301_094",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What kind of addressing uses a register as a pointer to data?",
    options: [
      "Direct addressing",
      "Indirect addressing",
      "Immediate addressing",
      "Relative addressing",
    ],
    correctAnswer: 1,
    explanation:
      "Using a register to hold an address is called indirect addressing.",
  },
  {
    id: "cpe301_095",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: In 64-bit mode, the LOOP instruction uses ECX as the loop counter.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 2,
    explanation:
      "In 64-bit mode, LOOP uses RCX as the loop counter (LOOPD uses ECX).",
  },
  {
    id: "cpe301_096",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "When copying a string in assembly, why is the `MOV` instruction usually performed in two steps (Memory to Register, Register to Memory)?",
    options: [
      "Because strings are too large for one instruction.",
      "Because the MOV instruction cannot have two memory operands.",
      "Because registers are faster than memory.",
      "Because it allows for character conversion.",
    ],
    correctAnswer: 1,
    explanation:
      "The MOV instruction rules prohibit both operands from being memory operands.",
  },
  {
    id: "cpe301_097",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `ptrB` is a QWORD variable containing the address of `arrayB`, what instruction loads that address into RSI in 64-bit mode?",
    options: [
      "MOV ESI, ptrB",
      "MOV RSI, ptrB",
      "MOV RSI, [ptrB]",
      "LEA RSI, ptrB",
    ],
    correctAnswer: 1,
    explanation:
      "`MOV RSI, ptrB` moves the 64-bit value (the address) stored in the variable `ptrB` into the `RSI` register.",
  },
  {
    id: "cpe301_098",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What happens if you use `inc [rsi]` without a PTR operator?",
    options: [
      "It increments the byte at RSI.",
      "It increments the pointer RSI.",
      "It causes an assembler error.",
      "It defaults to DWORD size.",
    ],
    correctAnswer: 2,
    explanation:
      "The operand size is ambiguous (byte? word?), so the assembler generates an 'operand must have size' error.",
  },
  {
    id: "cpe301_099",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which flag is set if an arithmetic operation generates a negative result?",
    options: ["Zero Flag", "Carry Flag", "Sign Flag", "Overflow Flag"],
    correctAnswer: 2,
    explanation:
      "The Sign Flag is set when the result of a signed arithmetic operation is negative (MSB is 1).",
  },
  {
    id: "cpe301_100",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "How is the Overflow Flag determined by the hardware during addition?",
    options: [
      "It is a copy of the high bit of the result.",
      "It is the carry out of the MSB XORed with the carry into the MSB.",
      "It is set if the result is zero.",
      "It is set if the result exceeds 255.",
    ],
    correctAnswer: 1,
    explanation:
      "Overflow is detected by XORing the carry *into* the high bit with the carry *out of* the high bit.",
  },
  {
    id: "cpe301_101",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: The `NEG` instruction changes the Sign Flag, Zero Flag, Carry Flag, and Overflow Flag.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation:
      "NEG affects the Carry, Zero, Sign, Overflow, Auxiliary Carry, and Parity flags according to the result.",
  },
  {
    id: "cpe301_102",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `EAX` contains `FFFFFFFFh`, what is the value of `EAX` after `INC EAX`?",
    options: ["FFFFFFFFh", "00000000h", "100000000h", "FFFFFFFEh"],
    correctAnswer: 1,
    explanation: "Incrementing the maximum value wraps around to 0.",
  },
  {
    id: "cpe301_103",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction is used to unconditionally jump to a label?",
    options: ["LOOP", "MOV", "JMP", "CALL"],
    correctAnswer: 2,
    explanation:
      "JMP (Jump) causes an unconditional transfer to a destination label.",
  },
  {
    id: "cpe301_104",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In the `AddSubTest` example, `mov cx, 1` followed by `sub cx, 1` results in which flag being set?",
    options: ["Sign Flag", "Carry Flag", "Zero Flag", "Overflow Flag"],
    correctAnswer: 2,
    explanation: "1 - 1 = 0. The result is zero, so the Zero Flag (ZF) is set.",
  },
  {
    id: "cpe301_105",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is the effect of `mov al, -128` followed by `sub al, 1` on a signed 8-bit integer?",
    options: [
      "AL = -129, OF = 0",
      "AL = +127, OF = 1",
      "AL = -127, OF = 0",
      "AL = 0, OF = 1",
    ],
    correctAnswer: 1,
    explanation:
      "-128 - 1 = -129. -129 is too small for a signed byte (min -128). It wraps to +127 (7Fh) and sets the Overflow Flag.",
  },
  {
    id: "cpe301_106",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `count` is a DWORD variable, what does `SIZEOF count` return?",
    options: ["1", "2", "4", "8"],
    correctAnswer: 2,
    explanation:
      "SIZEOF returns LENGTHOF * TYPE. For a single DWORD, 1 * 4 = 4.",
  },
  {
    id: "cpe301_107",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What allows you to view an array's contents in the Visual Studio debugger?",
    options: [
      "Watch Window",
      "Memory Window",
      "Registers Window",
      "Output Window",
    ],
    correctAnswer: 1,
    explanation:
      "The Memory Window allows viewing raw memory contents, useful for arrays.",
  },
  {
    id: "cpe301_108",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: The `JMP` instruction modifies the Instruction Pointer (EIP).",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 0,
    explanation:
      "JMP loads the offset of the destination into the instruction pointer, changing the execution flow.",
  },
  {
    id: "cpe301_109",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction sign-extends a byte in AL to a word in AX?",
    options: ["CBW", "CWD", "CDQ", "CWDE"],
    correctAnswer: 0,
    explanation:
      "CBW (Convert Byte to Word) sign-extends AL into AH. (Though not explicitly in the summary list, it's a standard related instruction, but based strictly on text provided, `MOVSX AX, AL` is the general form. Assuming general knowledge or implied coverage. If strict to text, MOVSX covers this).",
  },
  {
    id: "cpe301_110",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In the `SumArray_64` program, which register is used as the accumulator for the sum?",
    options: ["EAX", "RAX", "RCX", "RDI"],
    correctAnswer: 1,
    explanation: "The program uses `MOV RAX, 0` and `ADD RAX, [RDI]`.",
  },
  {
    id: "cpe301_111",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "When implementing `Rval = -Xval + (Yval - Zval)`, why is `NEG` used?",
    options: [
      "To subtract Xval",
      "To move Xval",
      "To invert the sign of Xval",
      "To add Xval",
    ],
    correctAnswer: 2,
    explanation:
      "The expression requires `-Xval`, so `NEG` is used to negate the value.",
  },
  {
    id: "cpe301_112",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: `LOOP` jumps if `ECX` is zero.",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation: "LOOP jumps only if ECX is *not* zero after decrementing.",
  },
  {
    id: "cpe301_113",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which operator is used to verify the operand size when it is ambiguous?",
    options: ["OFFSET", "TYPE", "PTR", "ALIGN"],
    correctAnswer: 2,
    explanation: "PTR is used to explicitly state the size (e.g., `BYTE PTR`).",
  },
  {
    id: "cpe301_114",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What does `mov eax, [arrayD + 4]` do?",
    options: [
      "Moves the first element of arrayD to EAX.",
      "Moves the second element of arrayD to EAX.",
      "Moves the address of arrayD to EAX.",
      "Adds 4 to the value in arrayD.",
    ],
    correctAnswer: 1,
    explanation:
      "Accesses the memory at offset +4, which is the second element of a DWORD array.",
  },
  {
    id: "cpe301_115",
    course: "CPE 301",
    chapter: "Chapter 4",
    text: "If `BX` contains a negative number, what happens to `CX` after `MOVSX CX, BL`?",
    options: [
      "It becomes a large positive number.",
      "It becomes the same negative number (sign-extended).",
      "It becomes zero.",
      "It is undefined.",
    ],
    correctAnswer: 1,
    explanation:
      "MOVSX sign-extends the source, preserving the sign in the larger destination.",
  },
  {
    id: "cpe301_116",
    course: "CPE 301",
    chapter: "Chapter 4",
    text: "Which of the following is an example of a base-index operand?",
    options: ["[EAX]", "[EAX + EBX]", "[EAX + 4]", "array[ESI]"],
    correctAnswer: 1,
    explanation:
      "A base-index operand combines two registers (e.g., [EAX + EBX]) to calculate an effective address.",
  },
  {
    id: "cpe301_117",
    course: "CPE 301",
    chapter: "Chapter 4",
    text: "When using indexed addressing with a scale factor, which of the following is NOT a valid scale factor?",
    options: ["1", "2", "4", "3"],
    correctAnswer: 3,
    explanation:
      "Valid scale factors correspond to standard data sizes: 1, 2, 4, and 8. 3 is not a valid scale factor.",
  },
  {
    id: "cpe301_118",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In 32-bit mode, what does the instruction `MOV EAX, arrayD[ESI*4]` assume about `arrayD`?",
    options: [
      "It is an array of Bytes.",
      "It is an array of Words.",
      "It is an array of Doublewords.",
      "It is an array of Quadwords.",
    ],
    correctAnswer: 2,
    explanation:
      "The scale factor 4 implies elements are 4 bytes wide, which corresponds to Doublewords.",
  },
  {
    id: "cpe301_119",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which directive is used to create a pointer type definition, such as `PBYTE`?",
    options: ["STRUCT", "UNION", "TYPEDEF", "MACRO"],
    correctAnswer: 2,
    explanation:
      "TYPEDEF is used to define user-defined types, including pointers (e.g., `PBYTE TYPEDEF PTR BYTE`).",
  },
  {
    id: "cpe301_120",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In the instruction `inc [esi]`, why is the `PTR` operator required?",
    options: [
      "To increment the pointer itself.",
      "To specify the size of the memory operand pointed to by ESI.",
      "To access protected memory.",
      "To use a register as an index.",
    ],
    correctAnswer: 1,
    explanation:
      "The assembler needs to know the size of the data at the address in ESI (byte, word, etc.) to generate the correct code.",
  },
  {
    id: "cpe301_121",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is the range of the relative offset for a `LOOP` instruction in 32-bit mode?",
    options: [
      "-32,768 to +32,767 bytes",
      "-128 to +127 bytes",
      "Anywhere in the code segment",
      "0 to 255 bytes",
    ],
    correctAnswer: 1,
    explanation:
      "The LOOP instruction uses a short jump, limited to a relative offset of -128 to +127 bytes from the current location.",
  },
  {
    id: "cpe301_122",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which steps does the `LOOP` instruction perform?",
    options: [
      "Compare ECX to 0, then Decrement ECX.",
      "Decrement ECX, then Compare ECX to 0.",
      "Increment ECX, then Compare ECX to limit.",
      "Compare ECX to 0, then Jump.",
    ],
    correctAnswer: 1,
    explanation:
      "LOOP first decrements ECX, then checks if the new value of ECX is not zero.",
  },
  {
    id: "cpe301_123",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What happens if `ECX` is 0 when the `LOOP` instruction is executed?",
    options: [
      "The loop terminates immediately.",
      "ECX decrements to FFFFFFFFh and the loop continues.",
      "The program generates a runtime error.",
      "ECX resets to the initial count.",
    ],
    correctAnswer: 1,
    explanation:
      "Because LOOP decrements *before* checking, 0 becomes -1 (FFFFFFFFh), causing the loop to repeat billions of times.",
  },
  {
    id: "cpe301_124",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In a nested loop, what must be done with the outer loop's counter (ECX) before entering the inner loop?",
    options: [
      "Set it to 0.",
      "Save it (e.g., on the stack or in a variable).",
      "Move it to EAX.",
      "Nothing, separate LOOP instructions use different counters.",
    ],
    correctAnswer: 1,
    explanation:
      "Since LOOP always uses ECX, the outer loop's value must be saved before the inner loop overwrites ECX, and restored afterwards.",
  },
  {
    id: "cpe301_125",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "When summing an integer array, why is the loop counter initialized to `LENGTHOF array`?",
    options: [
      "To ensure the sum fits in the register.",
      "To iterate exactly once for each element.",
      "To calculate the byte size of the array.",
      "To set the index register to the last element.",
    ],
    correctAnswer: 1,
    explanation:
      "LENGTHOF returns the number of elements, which is the correct count for the loop iterations.",
  },
  {
    id: "cpe301_126",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction is functionally equivalent to `SUB ECX, 1` followed by `JNZ destination`?",
    options: ["LOOP destination", "JMP destination", "DEC ECX", "CMP ECX, 0"],
    correctAnswer: 0,
    explanation:
      "The LOOP instruction performs `DEC ECX` and jumps if the result is non-zero (JNZ).",
  },
  {
    id: "cpe301_127",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In 64-bit mode, what is the effect of `MOV RAX, 80000000h`?",
    options: [
      "RAX = FFFFFFFF80000000h",
      "RAX = 0000000080000000h",
      "RAX = 8000000000000000h",
      "Assembler Error",
    ],
    correctAnswer: 1,
    explanation:
      "Moving a 32-bit constant to a 64-bit register clears the upper 32 bits. It does NOT sign extend.",
  },
  {
    id: "cpe301_128",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction allows a 32-bit register source to be sign-extended into a 64-bit destination register?",
    options: ["MOVSX", "MOVSXD", "MOVZX", "MOV"],
    correctAnswer: 1,
    explanation:
      "MOVSXD (Move with Sign-Extend Doubleword) is designed for this specific 32-to-64 bit operation.",
  },
  {
    id: "cpe301_129",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Why must the `OFFSET` operator be used with a 64-bit register in 64-bit mode?",
    options: [
      "Because offsets are 32-bit.",
      "Because offsets are 64-bit addresses.",
      "Because offsets are relative.",
      "Because offsets are signed.",
    ],
    correctAnswer: 1,
    explanation:
      "In 64-bit mode, memory addresses are 64 bits long, requiring a 64-bit register to hold them.",
  },
  {
    id: "cpe301_130",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What happens to the upper bits of a 64-bit register if you move an 8-bit memory operand into its lowest byte (e.g., `MOV AL, [mem]`)?",
    options: [
      "They are cleared.",
      "They are sign-extended.",
      "They are preserved (unchanged).",
      "They are inverted.",
    ],
    correctAnswer: 2,
    explanation:
      "Writing to 8-bit or 16-bit partial registers (like AL, AX) does NOT affect the upper bits of the full 64-bit register.",
  },
  {
    id: "cpe301_131",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In the 64-bit `SumArray` example, which register is used to dereference the array elements?",
    options: ["ESI", "RDI", "RCX", "RIP"],
    correctAnswer: 1,
    explanation:
      "The example uses RDI as the pointer to the array (indirect addressing).",
  },
  {
    id: "cpe301_132",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which status flag helps identify if a subtraction resulted in a negative number?",
    options: [
      "Zero Flag (ZF)",
      "Carry Flag (CF)",
      "Sign Flag (SF)",
      "Parity Flag (PF)",
    ],
    correctAnswer: 2,
    explanation:
      "The Sign Flag is set equal to the MSB of the result. If MSB is 1, the number is negative.",
  },
  {
    id: "cpe301_133",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `MOV AL, 0FFh` is followed by `ADD AL, 1`, what are the values of ZF and CF?",
    options: ["ZF=0, CF=0", "ZF=1, CF=1", "ZF=1, CF=0", "ZF=0, CF=1"],
    correctAnswer: 1,
    explanation:
      "FFh + 1 = 100h. The 8-bit result is 00h (ZF=1). The carry out is 1 (CF=1).",
  },
  {
    id: "cpe301_134",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction does NOT support memory-to-memory data transfer?",
    options: ["MOV", "MOVS (String instruction)", "PUSH", "POP"],
    correctAnswer: 0,
    explanation:
      "The basic `MOV` instruction does not permit two memory operands. (Note: MOVS is a special string instruction that does, but MOV does not).",
  },
  {
    id: "cpe301_135",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What does the `ALIGN 2` directive accomplish?",
    options: [
      "It adds 2 to the value of the next variable.",
      "It ensures the next variable starts at an even address.",
      "It creates a 2-byte variable.",
      "It aligns the code to a 2-bit boundary.",
    ],
    correctAnswer: 1,
    explanation:
      "ALIGN 2 forces the location counter to the next even address (word boundary) to optimize CPU access.",
  },
  {
    id: "cpe301_136",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `myBytes` is defined as `BYTE 10h, 20h, 30h, 40h`, what is the value of `LENGTHOF myBytes`?",
    options: ["1", "2", "4", "8"],
    correctAnswer: 2,
    explanation:
      "LENGTHOF counts the number of initializers. There are 4 bytes.",
  },
  {
    id: "cpe301_137",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `myArray` is `DWORD 1, 2, 3`, what is `SIZEOF myArray`?",
    options: ["3", "4", "12", "8"],
    correctAnswer: 2,
    explanation: "SIZEOF = LENGTHOF (3) * TYPE (4) = 12 bytes.",
  },
  {
    id: "cpe301_138",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which flag is set when an arithmetic operation results in a carry out of the most significant bit of the result?",
    options: [
      "Overflow Flag",
      "Carry Flag",
      "Sign Flag",
      "Auxiliary Carry Flag",
    ],
    correctAnswer: 1,
    explanation:
      "The Carry Flag (CF) tracks the carry out of the MSB for unsigned arithmetic.",
  },
  {
    id: "cpe301_139",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is the primary use of the Overflow Flag (OF)?",
    options: [
      "To indicate unsigned integer overflow.",
      "To indicate signed integer overflow.",
      "To indicate a zero result.",
      "To indicate an odd number of bits.",
    ],
    correctAnswer: 1,
    explanation:
      "The Overflow Flag is specifically for signed arithmetic, indicating the result is invalid for the storage size.",
  },
  {
    id: "cpe301_140",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: The `XCHG` instruction can accept immediate values (constants) as operands.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 2,
    explanation:
      "XCHG requires two mutable locations (registers or memory) to swap data; constants cannot be changed.",
  },
  {
    id: "cpe301_141",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction subtracts the source operand from the destination?",
    options: ["ADD", "DEC", "SUB", "NEG"],
    correctAnswer: 2,
    explanation: "SUB dest, source performs dest = dest - source.",
  },
  {
    id: "cpe301_142",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is the result of `NEG 0`?",
    options: ["0, CF=0", "0, CF=1", "-1, CF=1", "1, CF=0"],
    correctAnswer: 0,
    explanation:
      "Negating zero results in zero. The Carry flag is cleared (0) only when the operand is 0; otherwise it is set.",
  },
  {
    id: "cpe301_143",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which operator allows you to treat a variable as a different size than declared?",
    options: ["OFFSET", "PTR", "TYPE", "LABEL"],
    correctAnswer: 1,
    explanation:
      "The PTR operator overrides the declared size (e.g., `WORD PTR [eax]`).",
  },
  {
    id: "cpe301_144",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What does the `LABEL` directive do?",
    options: [
      "Allocates memory for a variable.",
      "Creates an alias for the current location with a specific size attribute.",
      "Defines a constant.",
      "Starts a loop.",
    ],
    correctAnswer: 1,
    explanation:
      "LABEL creates a name and size attribute for the current location without allocating storage.",
  },
  {
    id: "cpe301_145",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which register is known as the 'Counter Register'?",
    options: ["EAX", "EBX", "ECX", "EDX"],
    correctAnswer: 2,
    explanation:
      "ECX (Count Register) is used for loops and string operations.",
  },
  {
    id: "cpe301_146",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: `JMP` is a conditional transfer instruction.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation:
      "JMP is an UNconditional transfer. Conditional jumps are JE, JNE, etc.",
  },
  {
    id: "cpe301_147",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "How many times does the loop execute? `mov ecx, 3` `L1: dec ecx` `loop L1`",
    options: ["3 times", "2 times", "Infinite loop", "4 times"],
    correctAnswer: 2,
    explanation:
      "Inside the loop, `dec ecx` reduces count. Then `loop` decrements it *again*. Logic error likely leads to infinite loop or unexpected behavior as ECX skips 0.",
  },
  {
    id: "cpe301_148",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In 64-bit mode, arithmetic on a 32-bit register (e.g., `ADD EAX, EBX`) affects:",
    options: [
      "Only the lower 32 bits of RAX.",
      "The entire 64 bits of RAX (zeroing the upper half).",
      "The entire 64 bits of RAX (sign extending).",
      "Only AL.",
    ],
    correctAnswer: 1,
    explanation:
      "In 64-bit mode, the result of a 32-bit operation is zero-extended to the upper 32 bits of the destination 64-bit register.",
  },
  {
    id: "cpe301_149",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What represents the Auxiliary Carry Flag symbol in the Visual Studio debugger?",
    options: ["AF", "AC", "AX", "AU"],
    correctAnswer: 1,
    explanation: "The symbol for Auxiliary Carry in the debugger is AC.",
  },
  {
    id: "cpe301_150",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "To reverse an array in place, which addressing method is most suitable?",
    options: [
      "Immediate addressing",
      "Indirect addressing with two pointers (start and end)",
      "Direct addressing",
      "Stack addressing",
    ],
    correctAnswer: 1,
    explanation:
      "Using two pointers (e.g., ESI at start, EDI at end) and moving them towards each other is the standard way to reverse an array.",
  },
  {
    id: "cpe301_151",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `TYPE` returns 2, what data type is the operand?",
    options: ["BYTE", "WORD", "DWORD", "QWORD"],
    correctAnswer: 1,
    explanation: "TYPE 2 corresponds to a 2-byte WORD.",
  },
  {
    id: "cpe301_152",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction is used to reverse the sign of an integer?",
    options: ["NOT", "REV", "NEG", "SUB"],
    correctAnswer: 2,
    explanation: "NEG (Negate) reverses the sign (Two's Complement).",
  },
  {
    id: "cpe301_153",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In the instruction `MOV EAX, [EBX + ESI]`, what addressing mode is used?",
    options: ["Register Indirect", "Base-Indexed", "Direct", "Immediate"],
    correctAnswer: 1,
    explanation:
      "Base-Indexed addressing uses a base register (EBX) plus an index register (ESI).",
  },
  {
    id: "cpe301_154",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which of the following is true about the `JMP` instruction?",
    options: [
      "It saves the return address on the stack.",
      "It modifies the FLAGS register.",
      "It loads a new value into the Instruction Pointer (EIP/RIP).",
      "It only works within the current procedure.",
    ],
    correctAnswer: 2,
    explanation:
      "JMP works by loading the target address into the instruction pointer.",
  },
  {
    id: "cpe301_155",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "True or False: `MOVZX` can be used with a signed source operand to preserve the sign.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation:
      "False. MOVZX zero-extends, which destroys negative signs. MOVSX must be used for signed values.",
  },
  {
    id: "cpe301_156",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "If `EAX` is 100, what is the value after `NEG EAX`?",
    options: ["100", "-100", "0", "128"],
    correctAnswer: 1,
    explanation: "NEG converts 100 to -100.",
  },
  {
    id: "cpe301_157",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "When debugging, which window allows you to view the individual CPU flags?",
    options: ["Memory", "Watch", "Registers", "Disassembly"],
    correctAnswer: 2,
    explanation:
      "The Registers window (often with a right-click 'Flags' option) shows CPU flags.",
  },
  {
    id: "cpe301_158",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "What is the result of `TYPE` applied to a `BYTE` variable?",
    options: ["1", "2", "4", "8"],
    correctAnswer: 0,
    explanation: "A BYTE is 1 byte in size.",
  },
  {
    id: "cpe301_159",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "In the instruction `ADD EAX, EBX`, which operand is the destination?",
    options: ["EAX", "EBX", "Both", "Neither"],
    correctAnswer: 0,
    explanation: "The first operand (EAX) is the destination.",
  },
  {
    id: "cpe301_160",
    course: "CPE301",
    chapter: "Chapter 4",
    text: "Which instruction copies the low byte of the EFLAGS register into AH?",
    options: ["SAHF", "LAHF", "PUSHF", "POPF"],
    correctAnswer: 1,
    explanation: "LAHF (Load Status Flags into AH) performs this operation.",
  },
];

export default cpe301Chapter4;
