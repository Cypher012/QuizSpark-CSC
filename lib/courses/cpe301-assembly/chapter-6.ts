import { QuestionV2 } from "@/lib/quiz-types";

const CPE301Chapter6Part1: QuestionV2[] = [
  // SECTION 6.2: Boolean and Comparison Instructions
  {
    id: "CPE301_ch6_001",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which of the following actions is performed by the AND instruction?",
    options: [
      "Performs a boolean OR operation between two operands",
      "Performs a boolean AND operation and stores the result in the destination",
      "Performs a boolean AND operation but does not change the destination",
      "Inverts all bits in the destination operand",
    ],
    correctAnswer: 1,
    explanation:
      "The AND instruction performs a bitwise boolean AND operation between the source and destination operands and stores the result in the destination.",
  },
  {
    id: "CPE301_ch6_002",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "How does the OR instruction affect the Carry Flag (CF) and Overflow Flag (OF)?",
    options: [
      "It sets both CF and OF to 1",
      "It always clears both CF and OF to 0",
      "It leaves them unchanged",
      "It sets CF according to the result and clears OF",
    ],
    correctAnswer: 1,
    explanation:
      "The OR instruction (like AND and XOR) always clears the Carry Flag (CF) and Overflow Flag (OF) to 0.",
  },
  {
    id: "CPE301_ch6_003",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To 'mask' (clear) specific bits in a register while leaving others unchanged, which instruction is most appropriate?",
    options: ["OR", "XOR", "AND", "NOT"],
    correctAnswer: 2,
    explanation:
      "The AND instruction is used for masking (clearing) bits. ANDing a bit with 0 clears it, while ANDing with 1 preserves it.",
  },
  {
    id: "CPE301_ch6_004",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction would you use to toggle (invert) specific bits in an operand without affecting the others?",
    options: ["AND", "OR", "XOR", "TEST"],
    correctAnswer: 2,
    explanation:
      "The XOR instruction toggles bits. XORing a bit with 1 inverts it; XORing with 0 leaves it unchanged.",
  },
  {
    id: "CPE301_ch6_005",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What is the primary difference between the AND instruction and the TEST instruction?",
    options: [
      "TEST modifies the destination operand, while AND does not",
      "AND modifies the destination operand, while TEST only updates the flags",
      "TEST can only operate on 8-bit registers",
      "AND sets the Carry Flag, while TEST clears it",
    ],
    correctAnswer: 1,
    explanation:
      "The TEST instruction performs an implied AND operation to update flags (Sign, Zero, Parity) but does not store the result or modify the destination operand.",
  },
  {
    id: "CPE301_ch6_006",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If AL contains 00000101b, what is the value of the Zero Flag (ZF) after executing `TEST AL, 1`?",
    options: [
      "1 (Set)",
      "0 (Clear)",
      "Undefined",
      "It depends on the Carry Flag",
    ],
    correctAnswer: 1,
    explanation:
      "00000101 AND 00000001 results in 00000001 (non-zero). Therefore, the Zero Flag is cleared (0).",
  },
  {
    id: "CPE301_ch6_007",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction is functionally equivalent to `SUB` regarding flag updates, but does not modify the destination operand?",
    options: ["DEC", "NEG", "CMP", "TEST"],
    correctAnswer: 2,
    explanation:
      "The CMP (Compare) instruction performs an implied subtraction (Destination - Source) to update flags but does not modify the destination.",
  },
  {
    id: "CPE301_ch6_008",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: The NOT instruction affects the status flags (CF, ZF, SF, OF, etc.).",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation:
      "The NOT instruction inverts all bits in the operand but does NOT affect any of the CPU status flags.",
  },
  {
    id: "CPE301_ch6_009",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If you want to set the Zero Flag (ZF) to 1 without changing the value in the EAX register (assuming EAX is zero), which instruction could you use?",
    options: ["CMP EAX, 0", "MOV EAX, 1", "OR EAX, EAX", "XOR EAX, 1"],
    correctAnswer: 2,
    explanation:
      "`OR EAX, EAX` (or `AND EAX, EAX`) updates the Zero Flag based on the value of EAX without changing EAX itself. If EAX is 0, ZF becomes 1.",
  },
  {
    id: "CPE301_ch6_010",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which flag is set if the result of a signed comparison indicates that the destination is less than the source?",
    options: [
      "Carry Flag (CF)",
      "Zero Flag (ZF)",
      "Sign Flag (SF) exclusive-OR Overflow Flag (OF) is 1",
      "Parity Flag (PF)",
    ],
    correctAnswer: 2,
    explanation:
      "For signed comparison, 'Less Than' is detected when SF != OF.",
  },
  {
    id: "CPE301_ch6_011",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "In 64-bit mode, performing a `XOR RAX, RAX` instruction is a common way to:",
    options: [
      "Set all bits in RAX to 1",
      "Clear the RAX register to 0",
      "Divide RAX by 2",
      "Preserve the flags",
    ],
    correctAnswer: 1,
    explanation:
      "XORing a register with itself results in 0. This is a standard idiom for clearing a register.",
  },
  {
    id: "CPE301_ch6_012",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction sets the Zero Flag if the source operand contains even parity?",
    options: ["TEST", "CMP", "JP", "AND"],
    correctAnswer: 3,
    explanation:
      "Bitwise instructions like AND update the Parity Flag (PF). PF is set if the low byte has even parity. (Note: `JP` is a jump, not an instruction that *sets* the flag based on data).",
  },

  // SECTION 6.3: Conditional Jumps
  {
    id: "CPE301_ch6_013",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "The Jcond instructions (like JZ, JNZ) branch to a destination label based on:",
    options: [
      "The value of the ECX register",
      "The current state of the CPU Status Flags",
      "The contents of the stack",
      "The privilege level of the processor",
    ],
    correctAnswer: 1,
    explanation:
      "Conditional jumps decide whether to branch based on the state of specific CPU status flags (ZF, CF, SF, OF, PF).",
  },
  {
    id: "CPE301_ch6_014",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which jump instruction is equivalent to `JE` (Jump if Equal)?",
    options: [
      "JNE",
      "JZ (Jump if Zero)",
      "JC (Jump if Carry)",
      "JS (Jump if Sign)",
    ],
    correctAnswer: 1,
    explanation:
      "If two numbers are equal, their difference (CMP) is zero. Thus, Jump if Equal (JE) checks the same flag as Jump if Zero (JZ).",
  },
  {
    id: "CPE301_ch6_015",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which conditional jump should be used for unsigned comparisons when the destination is greater than the source?",
    options: [
      "JG (Jump if Greater)",
      "JA (Jump if Above)",
      "JL (Jump if Less)",
      "JO (Jump if Overflow)",
    ],
    correctAnswer: 1,
    explanation:
      "For unsigned comparisons, the terms 'Above' and 'Below' are used. JA (Jump if Above) is used when destination > source (unsigned).",
  },
  {
    id: "CPE301_ch6_016",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which conditional jump instruction is used for signed comparisons when the destination is less than the source?",
    options: [
      "JB (Jump if Below)",
      "JL (Jump if Less)",
      "JC (Jump if Carry)",
      "JNA (Jump if Not Above)",
    ],
    correctAnswer: 1,
    explanation:
      "For signed comparisons, 'Less' and 'Greater' are used. JL (Jump if Less) is the correct instruction.",
  },
  {
    id: "CPE301_ch6_017",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "The instruction `JNC` will jump to the target label if:",
    options: [
      "The Carry Flag is 1",
      "The Carry Flag is 0",
      "The Zero Flag is 1",
      "The Sign Flag is 0",
    ],
    correctAnswer: 1,
    explanation: "JNC stands for Jump if No Carry, meaning it jumps if CF = 0.",
  },
  {
    id: "CPE301_ch6_018",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If you execute `CMP EAX, EBX` and EAX is 5 and EBX is 10 (unsigned), which jump will be taken?",
    options: [
      "JA (Jump if Above)",
      "JB (Jump if Below)",
      "JE (Jump if Equal)",
      "JZ (Jump if Zero)",
    ],
    correctAnswer: 1,
    explanation:
      "5 is less than 10. In unsigned terminology, 5 is 'Below' 10. JB (Jump if Below) will be taken.",
  },
  {
    id: "CPE301_ch6_019",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: The `JCXZ` instruction jumps if the ECX register is equal to Zero, regardless of the Zero Flag state.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 0,
    explanation:
      "JCXZ (Jump if CX is Zero) and JECXZ (Jump if ECX is Zero) examine the register value itself, not the status flags.",
  },
  {
    id: "CPE301_ch6_020",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "When implementing a high-level `if(val1 > val2)` structure where `val1` and `val2` are signed integers, which instructions are typically used?",
    options: [
      "CMP followed by JA",
      "CMP followed by JG",
      "SUB followed by JC",
      "TEST followed by JZ",
    ],
    correctAnswer: 1,
    explanation:
      "CMP performs the comparison. Since variables are signed, JG (Jump if Greater) is the correct conditional jump.",
  },
  {
    id: "CPE301_ch6_021",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction is used to set the Carry Flag explicitly?",
    options: ["CLC", "STC", "CMC", "SEC"],
    correctAnswer: 1,
    explanation: "STC (Set Carry Flag) sets CF to 1.",
  },
  {
    id: "CPE301_ch6_022",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What does the `BT` (Bit Test) instruction do?",
    options: [
      "Copies a specific bit from the operand to the Carry Flag",
      "Sets a bit in the destination operand",
      "Inverts a bit in the destination operand",
      "Clears the Zero flag if the bit is 1",
    ],
    correctAnswer: 0,
    explanation:
      "The BT instruction copies the value of a selected bit into the Carry Flag.",
  },

  // SECTION 6.4: Conditional Loop Instructions
  {
    id: "CPE301_ch6_023",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "The `LOOPZ` (or `LOOPE`) instruction repeats the loop while:",
    options: [
      "ECX > 0 AND ZF = 1",
      "ECX > 0 AND ZF = 0",
      "ECX = 0 OR ZF = 1",
      "ZF = 1 only (ignores ECX)",
    ],
    correctAnswer: 0,
    explanation:
      "LOOPZ/LOOPE decrements ECX and loops if ECX is not zero AND the Zero Flag is set (meaning the comparison condition was Equal).",
  },
  {
    id: "CPE301_ch6_024",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction is best suited for scanning an array to find the first nonzero value?",
    options: [
      "LOOPE (Loop while Equal)",
      "LOOPNE (Loop while Not Equal)",
      "JNZ (Jump if Not Zero)",
      "LOOP",
    ],
    correctAnswer: 0,
    explanation:
      "Scanning for a non-zero value implies we continue looping as long as we find zeros (Equal to zero). Therefore, LOOPE (Loop while Equal) is used.",
  },
  {
    id: "CPE301_ch6_025",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If `ECX` is 0 at the beginning of a `LOOPNZ` instruction block, how many times will the loop typically execute (in 32-bit mode)?",
    options: [
      "0 times",
      "1 time",
      "4,294,967,296 times (2^32)",
      "Indefinitely",
    ],
    correctAnswer: 2,
    explanation:
      "Like the standard LOOP instruction, if ECX is 0, it decrements to FFFFFFFFh and continues, executing 2^32 times (unless the ZF condition breaks it early).",
  },
  {
    id: "CPE301_ch6_026",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: `LOOPE` and `LOOPZ` are different mnemonics for the same machine instruction.",
    options: ["False", "Maybe", "True", "I don't know"],
    correctAnswer: 2,
    explanation:
      "They are synonyms for the same opcode, checking ECX and the Zero Flag.",
  },

  // SECTION 6.5: Conditional Structures
  {
    id: "CPE301_ch6_027",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To implement a Compound boolean AND expression (if X > Y AND Z > A) in assembly, how is the control flow usually managed?",
    options: [
      "If the first condition is False, jump immediately to the ELSE/Exit label (Short-Circuit)",
      "Evaluate both conditions, store results, then AND them",
      "Use the AND instruction on the variables directly",
      "Use the `.AND` directive",
    ],
    correctAnswer: 0,
    explanation:
      "Assembly implementations typically use short-circuit evaluation: if the first condition fails, the code jumps over the second condition check directly to the false block.",
  },
  {
    id: "CPE301_ch6_028",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Implementing a `WHILE` loop in assembly typically involves:",
    options: [
      "Checking the condition at the top; if false, jump to end. Jump back to top at bottom.",
      "Executing the body once, then checking the condition at the bottom.",
      "Using the LOOP instruction only.",
      "Using the `.IF` directive.",
    ],
    correctAnswer: 0,
    explanation:
      "A standard WHILE loop checks the condition before the first iteration. It involves a comparison/jump at the top and an unconditional jump at the bottom back to the top.",
  },
  {
    id: "CPE301_ch6_029",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What is Table-Driven Selection?",
    options: [
      "Using a database table to store logic",
      "Using an array (table) of offsets/pointers to lookup procedures or labels based on an input value",
      "Using the HTML <table> tag",
      "Using a switch statement in C++",
    ],
    correctAnswer: 1,
    explanation:
      "Table-driven selection uses a data table containing lookup values and procedure offsets (pointers) to avoid long chains of compare/jump instructions.",
  },
  {
    id: "CPE301_ch6_030",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction effectively converts a character in AL from lowercase to uppercase by manipulating bits?",
    options: [
      "OR AL, 00100000b",
      "AND AL, 11011111b",
      "XOR AL, 11111111b",
      "NOT AL",
    ],
    correctAnswer: 1,
    explanation:
      "Lowercase ASCII letters (e.g., 'a'=61h) differ from uppercase (e.g., 'A'=41h) by bit 5. Clearing bit 5 (AND with 11011111b or DFh) converts lowercase to uppercase.",
  },

  // SECTION 6.7: Conditional Control Flow Directives
  {
    id: "CPE301_ch6_031",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "MASM provides directives like `.IF`, `.ELSE`, and `.ENDIF` to:",
    options: [
      "Execute logic at assembly time (conditional assembly)",
      "Generate the corresponding CMP and Conditional Jump instructions automatically at runtime",
      "Create macros",
      "Debug the program",
    ],
    correctAnswer: 1,
    explanation:
      "These runtime directives simplify coding by automatically generating the low-level compare and jump instructions needed for control flow.",
  },
  {
    id: "CPE301_ch6_032",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which relational operator symbol is used with MASM directives for 'Not Equal'?",
    options: ["<>", "!=", "NE", "~="],
    correctAnswer: 1,
    explanation:
      "MASM directives use C-style operators like `!=` for Not Equal (though standard mnemonics like JNE are used in raw instructions).",
  },
  {
    id: "CPE301_ch6_033",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Using the `.REPEAT` and `.UNTIL` directives generates a loop that checks the condition:",
    options: [
      "At the top of the loop",
      "At the bottom of the loop (Post-test)",
      "In the middle of the loop",
      "At assembly time only",
    ],
    correctAnswer: 1,
    explanation:
      "`.REPEAT` ... `.UNTIL` generates a post-test loop (like do-while), evaluating the condition after the body executes.",
  },

  // MIXED / SCENARIO QUESTIONS
  {
    id: "CPE301_ch6_034",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "You need to check if a 32-bit integer in EAX is even. Which instruction is most efficient?",
    options: ["DIV EAX, 2", "TEST EAX, 1", "CMP EAX, 2", "OR EAX, 1"],
    correctAnswer: 1,
    explanation:
      "Checking the least significant bit (bit 0) determines parity. `TEST EAX, 1` checks bit 0 without modifying EAX. If Zero Flag is set (result 0), it is even.",
  },
  {
    id: "CPE301_ch6_035",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What value will the Zero Flag contain after `CMP val1, val2` if `val1` equals `val2`?",
    options: ["0", "1", "Undefined", "It depends on the sign"],
    correctAnswer: 1,
    explanation:
      "If operands are equal, the subtraction result is 0, so the Zero Flag (ZF) is set to 1.",
  },
  {
    id: "CPE301_ch6_036",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which flags are updated by the `SUB` instruction?",
    options: [
      "ZF only",
      "CF and OF only",
      "CF, ZF, SF, OF, AF, PF",
      "No flags are updated",
    ],
    correctAnswer: 2,
    explanation:
      "Arithmetic instructions like SUB (and ADD) update all status flags: Carry, Zero, Sign, Overflow, Auxiliary Carry, and Parity.",
  },
  {
    id: "CPE301_ch6_037",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If you perform `CMP AL, BL` where AL=127 and BL=-128 (signed comparison), which jump would be taken?",
    options: ["JL (Jump if Less)", "JG (Jump if Greater)", "JE", "JZ"],
    correctAnswer: 1,
    explanation:
      "127 is greater than -128. Therefore, JG (Jump if Greater) would be taken.",
  },
  {
    id: "CPE301_ch6_038",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: The `BTS` (Bit Test and Set) instruction copies a bit to the Carry Flag and then sets that bit in the destination operand.",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 1,
    explanation:
      "BTS copies the specified bit to CF and then sets the bit to 1 in the destination.",
  },
  {
    id: "CPE301_ch6_039",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To jump if the Sign Flag (SF) is set to 1, which mnemonic should be used?",
    options: ["JS", "JNS", "JP", "JO"],
    correctAnswer: 0,
    explanation: "JS stands for Jump if Sign (SF=1).",
  },
  {
    id: "CPE301_ch6_040",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What indicates a 'Carry' condition when subtracting unsigned integers?",
    options: [
      "The result is zero",
      "The destination operand is smaller than the source operand",
      "The result is negative",
      "The Overflow Flag is set",
    ],
    correctAnswer: 1,
    explanation:
      "In unsigned subtraction, a Carry (borrow) occurs if the number being subtracted (source) is larger than the number it is being subtracted from (destination).",
  },
  {
    id: "CPE301_ch6_041",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction does NOT exist in the x86 instruction set?",
    options: [
      "JNLE (Jump if Not Less or Equal)",
      "JGE (Jump if Greater or Equal)",
      "JNZ (Jump if Not Zero)",
      "JUE (Jump if Unsigned Equal)",
    ],
    correctAnswer: 3,
    explanation:
      "JUE is not a standard mnemonic. Unsigned equality is just JE (Jump if Equal).",
  },
  {
    id: "CPE301_ch6_042",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To check if the Overflow Flag (OF) is set, you can use:",
    options: ["JO", "JNO", "JS", "JC"],
    correctAnswer: 0,
    explanation: "JO stands for Jump if Overflow (OF=1).",
  },
  {
    id: "CPE301_ch6_043",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Logic for `IsDigit` (checking if a character is '0' through '9') usually involves:",
    options: [
      "A single CMP instruction",
      "Two CMP instructions (>= '0' AND <= '9')",
      "An XOR instruction",
      "A LOOP instruction",
    ],
    correctAnswer: 1,
    explanation:
      "To check a range, you verify the value is >= the lower bound AND <= the upper bound.",
  },
  {
    id: "CPE301_ch6_044",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "When using the `.WHILE` directive, which instruction causes the loop to terminate immediately (break)?",
    options: [".EXIT", ".BREAK", ".STOP", ".ENDW"],
    correctAnswer: 1,
    explanation:
      ".BREAK is the directive used to exit a loop structure immediately.",
  },
  {
    id: "CPE301_ch6_045",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which logic gate operation produces a 1 only if both inputs are 1?",
    options: ["OR", "XOR", "AND", "NOT"],
    correctAnswer: 2,
    explanation: "AND requires both inputs to be 1 to produce a 1.",
  },
  {
    id: "CPE301_ch6_046",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: The `JECXZ` instruction is useful when you want to avoid a loop executing if the counter is initially zero.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 0,
    explanation:
      "JECXZ checks if ECX is zero and jumps, often over a loop body, preventing the loop from running 2^32 times if initialized to 0.",
  },
  {
    id: "CPE301_ch6_047",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "In the context of Finite State Machines (FSM), what represents a 'state'?",
    options: [
      "A specific value in a register or variable representing the current step in a process",
      "The value of the Instruction Pointer",
      "The total memory usage",
      "The size of the hard drive",
    ],
    correctAnswer: 0,
    explanation:
      "In an FSM, a state is a condition or situation in the logic flow, often represented by a number or node in a graph.",
  },
  {
    id: "CPE301_ch6_048",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If AL contains 11001100b and you execute `AND AL, 00001111b`, what is the result?",
    options: ["11000000b", "00001100b", "11001111b", "00000000b"],
    correctAnswer: 1,
    explanation:
      "Upper 4 bits are masked (cleared). Lower 4 bits (1100) are preserved. Result: 00001100b.",
  },
  {
    id: "CPE301_ch6_049",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction toggles the Zero Flag?",
    options: [
      "There is no single instruction to toggle ZF",
      "NOT ZF",
      "CMC (Complement Carry) - wait, that's Carry",
      "TZF",
    ],
    correctAnswer: 0,
    explanation:
      "There is no dedicated instruction to toggle the Zero Flag. (CMC toggles Carry, not Zero).",
  },
  {
    id: "CPE301_ch6_050",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "For a signed comparison `CMP A, B`, which condition indicates A > B?",
    options: ["ZF = 0 and SF = OF", "ZF = 1", "CF = 0", "SF != OF"],
    correctAnswer: 0,
    explanation:
      "Greater Than (Signed) means Not Equal (ZF=0) AND the Sign equals the Overflow (SF=OF).",
  },
  {
    id: "CPE301_ch6_051",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction allows checking if a value is within a specific bit-mapped set membership?",
    options: ["BT (Bit Test)", "SET", "MEM", "SCAN"],
    correctAnswer: 0,
    explanation:
      "BT can test if a specific bit index (representing a set member) is set to 1.",
  },
  {
    id: "CPE301_ch6_052",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "The `SETz` (Set if Zero) instruction sets the destination byte to:",
    options: [
      "1 if the Zero Flag is set, 0 otherwise",
      "0 if the Zero Flag is set, 1 otherwise",
      "FFh if the Zero Flag is set",
      "The value of the Zero Flag directly",
    ],
    correctAnswer: 0,
    explanation:
      "SETcc instructions set the destination byte to 1 if the condition is true, and 0 if false.",
  },
  {
    id: "CPE301_ch6_053",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: The `OR` instruction can be used to check if a register is zero without modifying it.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 2,
    explanation:
      "False. `OR` modifies the destination (though `OR Reg, Reg` doesn't change the value, it writes the result). `TEST` is the proper instruction to check without 'modifying' (writing back) conceptually, although `OR Reg, Reg` is effectively harmless to the value.",
  },
  {
    id: "CPE301_ch6_054",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What does the instruction `CMC` do?",
    options: [
      "Clears the Carry Flag",
      "Complements (Inverts) the Carry Flag",
      "Compares Characters",
      "Calls a Macro",
    ],
    correctAnswer: 1,
    explanation: "CMC stands for Complement Carry Flag.",
  },
  {
    id: "CPE301_ch6_055",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "When writing a loop that terminates when a value is found (e.g., searching for the letter 'A'), which structure is most appropriate?",
    options: [
      "A WHILE loop with a condition `char != 'A'`",
      "An unconditional JMP",
      "A REPEAT loop with condition `char == 'Z'`",
      "A LOOP instruction with ECX=1",
    ],
    correctAnswer: 0,
    explanation:
      "A loop that continues *while* the value is NOT found (`!= 'A'`) is the standard logic for a search.",
  },
  {
    id: "CPE301_ch6_056",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "In a Table-Driven selection, the table typically contains:",
    options: [
      "Just the lookup keys",
      "Lookup keys and associated procedure offsets (addresses)",
      "The entire source code of the procedures",
      "Random numbers",
    ],
    correctAnswer: 1,
    explanation:
      "The table maps a key (input) to an action (procedure address).",
  },
  {
    id: "CPE301_ch6_057",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which flags are used to detect unsigned arithmetic errors?",
    options: ["Overflow Flag", "Carry Flag", "Sign Flag", "Parity Flag"],
    correctAnswer: 1,
    explanation:
      "The Carry Flag indicates overflow/underflow for unsigned arithmetic.",
  },
  {
    id: "CPE301_ch6_058",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If `EAX` = 5 and `EBX` = 5, what happens after `CMP EAX, EBX`?",
    options: ["ZF=1, CF=0", "ZF=0, CF=1", "ZF=0, CF=0", "ZF=1, CF=1"],
    correctAnswer: 0,
    explanation:
      "5 - 5 = 0. Zero Flag is set (1). No borrow occurred, so Carry Flag is 0.",
  },
  {
    id: "CPE301_ch6_059",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To clear the Sign Flag, you could execute:",
    options: [
      "AND EAX, 0",
      "OR EAX, 1",
      "Any instruction that produces a positive result",
      "CLS",
    ],
    correctAnswer: 2,
    explanation:
      "There is no direct `CLS` instruction. Executing an operation resulting in a positive number (like `AND EAX, 0` -> 0 is positive) clears SF.",
  },
  {
    id: "CPE301_ch6_060",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction does NOT modify the operand but updates flags?",
    options: ["TEST", "XOR", "NOT", "NEG"],
    correctAnswer: 0,
    explanation: "TEST is the non-destructive version of AND.",
  },
  {
    id: "CPE301_ch6_061",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What does `JPE` (Jump if Parity Even) check?",
    options: ["PF = 1", "PF = 0", "ZF = 1", "OF = 1"],
    correctAnswer: 0,
    explanation: "The Parity Flag is set (1) if parity is even.",
  },
  {
    id: "CPE301_ch6_062",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: In 64-bit mode, the `CMP` instruction acts differently on the flags than in 32-bit mode.",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation:
      "The flag behavior for CMP is consistent across modes; only operand sizes change.",
  },
  {
    id: "CPE301_ch6_063",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Short-circuit evaluation means:",
    options: [
      "Evaluating all parts of an expression regardless of outcome",
      "Stopping evaluation as soon as the result is determined",
      "Using short jumps only",
      "Causing a hardware short circuit",
    ],
    correctAnswer: 1,
    explanation:
      "Short-circuit evaluation stops processing a compound boolean expression as soon as the final truth value is known (e.g., if the first part of an AND is false).",
  },
  {
    id: "CPE301_ch6_064",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which operator matches the `.IF` directive for 'Greater Than or Equal' (Signed)?",
    options: [">=", "GE", "GTE", "AE"],
    correctAnswer: 0,
    explanation: "MASM directives support the C-style `>=` operator.",
  },
  {
    id: "CPE301_ch6_065",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "A state machine that verifies a signed integer must handle:",
    options: [
      "Optional sign (+/-) followed by digits",
      "Letters A-Z",
      "Floating point dots",
      "Only digits 0-9",
    ],
    correctAnswer: 0,
    explanation:
      "Validating a signed integer requires handling an optional leading plus or minus sign, followed by a sequence of digits.",
  },
  {
    id: "CPE301_ch6_066",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Result of `OR AL, 11111111b`?",
    options: [
      "AL = 00000000b",
      "AL = 11111111b",
      "AL is unchanged",
      "AL is inverted",
    ],
    correctAnswer: 1,
    explanation:
      "ORing anything with 1s results in 1s. AL becomes FFh (all 1s).",
  },
  {
    id: "CPE301_ch6_067",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If `CMP` sets ZF=0 and CF=0 (Unsigned), what is the relationship?",
    options: [
      "Dest > Source",
      "Dest < Source",
      "Dest = Source",
      "Dest <= Source",
    ],
    correctAnswer: 0,
    explanation:
      "Not Equal (ZF=0) and No Carry (CF=0) implies Destination is strictly Greater than Source.",
  },
  {
    id: "CPE301_ch6_068",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction converts a bit index to a bit mask automatically?",
    options: ["BTS (Bit Test and Set)", "MOV", "LEA", "ADC"],
    correctAnswer: 0,
    explanation:
      "Instructions like BT, BTS, BTR take a bit position index and internally generate the mask to access that specific bit.",
  },
  {
    id: "CPE301_ch6_069",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "The `.ELSEIF` directive allows you to:",
    options: [
      "Nest loops",
      "Create a multi-branch conditional structure (like a switch or ladder)",
      "Define variables",
      "End a program",
    ],
    correctAnswer: 1,
    explanation:
      ".ELSEIF adds checking for additional conditions if the previous .IF was false.",
  },
  {
    id: "CPE301_ch6_070",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To toggle the Zero Flag (ZF) intentionally, one might:",
    options: [
      "There is no direct way; you must perform an arithmetic/logical op",
      "Use the TZF instruction",
      "Use `SAHF` with a specific AH value",
      "Use `STZ`",
    ],
    correctAnswer: 2,
    explanation:
      "SAHF loads the AH register into the status flags. By setting bit 6 of AH and executing SAHF, you can force ZF to 1.",
  },
  {
    id: "CPE301_ch6_071",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: The `LOOPNE` instruction decrements ECX and jumps if ECX != 0 AND ZF = 0.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation:
      "LOOPNE (Loop Not Equal) continues looping as long as the counter is valid (ECX!=0) AND the condition 'Not Equal' (ZF=0) holds.",
  },
  {
    id: "CPE301_ch6_072",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which directive marks the end of a `.WHILE` loop?",
    options: [".ENDW", ".ENDWHILE", ".WEND", ".LOOP"],
    correctAnswer: 0,
    explanation: ".ENDW matches with .WHILE.",
  },
  {
    id: "CPE301_ch6_073",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "The `BTR` instruction performs which action?",
    options: [
      "Bit Test and Reset (Clear)",
      "Bit Test and Rotate",
      "Branch to Register",
      "Byte Test Register",
    ],
    correctAnswer: 0,
    explanation: "BTR copies the bit to CF and then Resets (Clears) it to 0.",
  },
  {
    id: "CPE301_ch6_074",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which jump mnemonic is synonymous with `JB` (Jump Below)?",
    options: [
      "JNAE (Jump Not Above or Equal)",
      "JC (Jump Carry)",
      "Both A and B",
      "None of the above",
    ],
    correctAnswer: 2,
    explanation:
      "Below, Carry, and Not Above or Equal all check for CF=1. They are synonyms.",
  },
  {
    id: "CPE301_ch6_075",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If `EAX` is negative, `TEST EAX, 80000000h` sets which flag?",
    options: [
      "Zero Flag = 0",
      "Zero Flag = 1",
      "Carry Flag = 1",
      "Overflow Flag = 1",
    ],
    correctAnswer: 0,
    explanation:
      "80000000h masks the MSB (sign bit). If EAX is negative, MSB is 1. 1 AND 1 = 1 (Non-Zero). Thus, ZF is cleared (0).",
  },
  {
    id: "CPE301_ch6_076",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which of the following instructions forces the execution flow to a new address regardless of flags?",
    options: ["JMP", "JNZ", "JE", "LOOP"],
    correctAnswer: 0,
    explanation: "JMP is an unconditional jump.",
  },
  {
    id: "CPE301_ch6_077",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What is the purpose of the `.CONTINUE` directive inside a `.WHILE` loop?",
    options: [
      "It terminates the loop.",
      "It jumps to the bottom of the loop to re-evaluate the condition.",
      "It pauses the program.",
      "It prints a message.",
    ],
    correctAnswer: 1,
    explanation:
      ".CONTINUE skips the remaining instructions in the current iteration and jumps to the loop evaluation logic.",
  },
  {
    id: "CPE301_ch6_078",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "The Parity Flag was originally designed for:",
    options: [
      "Checking data integrity in communications",
      "Signed arithmetic",
      "64-bit addressing",
      "Floating point math",
    ],
    correctAnswer: 0,
    explanation:
      "Parity was used in early communication to detect transmission errors (even/odd bit counts).",
  },
  {
    id: "CPE301_ch6_079",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: The `XOR` instruction can be used to check if two registers contain the same value.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation:
      "True. `XOR Reg1, Reg2` sets ZF=1 if Reg1 and Reg2 are identical (result is 0). However, it destroys the destination content.",
  },
  {
    id: "CPE301_ch6_080",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which flag is LEAST relevant to the `JA` (Jump Above) instruction?",
    options: [
      "Sign Flag (SF)",
      "Carry Flag (CF)",
      "Zero Flag (ZF)",
      "Both CF and ZF are used",
    ],
    correctAnswer: 0,
    explanation:
      "JA is an unsigned jump. It checks CF and ZF. The Sign Flag (SF) is relevant to signed jumps (like JG), not unsigned ones.",
  },
  {
    id: "CPE301_ch6_081",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To shift the lower 4 bits of AL to the upper 4 bits, you could use:",
    options: ["SHL AL, 4", "SHR AL, 4", "ROR AL, 4", "ROL AL, 4"],
    correctAnswer: 0,
    explanation: "Shifting Left (SHL) by 4 moves bits 0-3 to positions 4-7.",
  },
  {
    id: "CPE301_ch6_082",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If `CMP` leaves the flags as SF=0, OF=1, what is the relationship (Signed)?",
    options: ["Less Than", "Greater Than", "Equal", "Cannot determine"],
    correctAnswer: 0,
    explanation:
      "Signed Less Than occurs when SF != OF. Here 0 != 1, so it is Less Than.",
  },
  {
    id: "CPE301_ch6_083",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction does NOT support immediate operands?",
    options: ["CMP", "TEST", "AND", "None; all support immediates"],
    correctAnswer: 3,
    explanation:
      "CMP, TEST, AND, OR, XOR all support immediate operands (e.g., `CMP EAX, 5`).",
  },
  {
    id: "CPE301_ch6_084",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "A 'Null' pointer in assembly usually corresponds to the value:",
    options: ["0", "-1", "0xFFFFFFFF", "1"],
    correctAnswer: 0,
    explanation: "Null is typically represented as address 0.",
  },
  {
    id: "CPE301_ch6_085",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If `ECX` = 0, executing `LOOP` will decrement ECX to:",
    options: ["FFFFFFFFh", "0", "1", "Error"],
    correctAnswer: 0,
    explanation: "0 - 1 = -1 (FFFFFFFFh in 32-bit).",
  },
  {
    id: "CPE301_ch6_086",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: `CMP` is really a subtraction instruction.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 0,
    explanation:
      "True. CMP performs subtraction internally to set flags but discards the result.",
  },
  {
    id: "CPE301_ch6_087",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which directive allows for checking the Carry flag directly in high-level syntax?",
    options: [".IF CARRY?", ".IF CF", ".IF C", ".IF CARRY"],
    correctAnswer: 0,
    explanation:
      "MASM provides condition codes like `CARRY?`, `ZERO?`, `SIGN?` for use in `.IF` statements.",
  },
  {
    id: "CPE301_ch6_088",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What does the `NOT` instruction do to the Zero Flag?",
    options: ["Nothing", "Sets it", "Clears it", "Inverts it"],
    correctAnswer: 0,
    explanation: "NOT does not affect any flags.",
  },
  {
    id: "CPE301_ch6_089",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction checks if the least significant bit of AL is 1?",
    options: ["TEST AL, 1", "CMP AL, 1", "AND AL, 1", "All of the above"],
    correctAnswer: 0,
    explanation:
      "TEST AL, 1 is the specific non-destructive test. (CMP checks if the whole value is 1; AND modifies AL).",
  },
  {
    id: "CPE301_ch6_090",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Using `JA` after `CMP -5, 5` (signed integers interpreted as unsigned) results in:",
    options: [
      "Jump Taken",
      "Jump Not Taken",
      "Runtime Error",
      "Processor Halt",
    ],
    correctAnswer: 0,
    explanation:
      "-5 is represented as a large positive number (FFFFFFFBh) in unsigned binary. 5 is 00000005h. Large > Small, so 'Above' is true. Jump Taken.",
  },
  {
    id: "CPE301_ch6_091",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which flags are updated by `TEST`?",
    options: ["SF, ZF, PF (CF/OF cleared)", "Only ZF", "All flags", "None"],
    correctAnswer: 0,
    explanation:
      "TEST updates Sign, Zero, and Parity flags based on the AND result. It clears Carry and Overflow.",
  },
  {
    id: "CPE301_ch6_092",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "In assembly, `str1 == str2` comparison usually requires:",
    options: [
      "A loop comparing characters one by one",
      "A single CMP instruction",
      "The `.EQUAL` directive",
      "MOV instruction",
    ],
    correctAnswer: 0,
    explanation:
      "You cannot compare entire strings with one CMP. You must loop through bytes.",
  },
  {
    id: "CPE301_ch6_093",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction would you use to check if the value in EAX is zero?",
    options: ["OR EAX, EAX", "CMP EAX, 0", "TEST EAX, EAX", "All of the above"],
    correctAnswer: 3,
    explanation:
      "All listed options effectively check if EAX is zero and set the Zero Flag accordingly.",
  },
  {
    id: "CPE301_ch6_094",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: The `.ENDIF` directive is optional if the `.IF` block only has one line.",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation: "Every `.IF` block must be closed with `.ENDIF`.",
  },
  {
    id: "CPE301_ch6_095",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To clear the Overflow Flag, you can use:",
    options: [
      "OR EAX, 0",
      "MOV OF, 0",
      "CLO",
      "There is no specific instruction; use logic like `OR`",
    ],
    correctAnswer: 3,
    explanation:
      "There is no `CLO` instruction. Logic instructions like `OR` clear OF.",
  },
  {
    id: "CPE301_ch6_096",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If `ECX` is 5, `LOOP` decrements it to 4 and jumps. If `ECX` is 1, `LOOP` decrements to 0 and:",
    options: ["Does not jump", "Jumps", "Halts", "Resets ECX"],
    correctAnswer: 0,
    explanation:
      "LOOP jumps only if the *new* value of ECX is not zero. If it reaches 0, it falls through.",
  },
  {
    id: "CPE301_ch6_097",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which conditional jump pairs are NOT synonyms?",
    options: ["JZ / JE", "JC / JB", "JA / JG", "JP / JPE"],
    correctAnswer: 2,
    explanation:
      "JA (Jump Above - Unsigned) is NOT a synonym for JG (Jump Greater - Signed).",
  },
  {
    id: "CPE301_ch6_098",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "The `BTC` instruction:",
    options: [
      "Bit Test and Complement (Toggle)",
      "Bit Test and Clear",
      "Branch To Code",
      "Byte Transfer Control",
    ],
    correctAnswer: 0,
    explanation:
      "BTC copies the bit to CF and Complements (inverts) it in the destination.",
  },
  {
    id: "CPE301_ch6_099",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which status flag indicates that the last arithmetic operation resulted in a number too large for the unsigned destination?",
    options: ["Carry Flag", "Overflow Flag", "Sign Flag", "Zero Flag"],
    correctAnswer: 0,
    explanation: "Unsigned overflow is tracked by the Carry Flag.",
  },
  {
    id: "CPE301_ch6_100",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What does `JNC` stand for?",
    options: [
      "Jump if Not Carry",
      "Jump if Not Clear",
      "Jump if No Compare",
      "Jump if Not Counter",
    ],
    correctAnswer: 0,
    explanation: "Jump if Not Carry (CF=0).",
  },
];

const CPE301Chapter6Part2: QuestionV2[] = [
  // SECTION 6.5: Conditional Structures & Logic
  {
    id: "cpe301_101",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "When implementing a compound boolean AND expression (e.g., `if (X > Y) AND (Z < T)`), which optimization technique is standard in assembly?",
    options: [
      "Short-circuit evaluation",
      "Parallel execution",
      "Speculative evaluation",
      "Redundant checking",
    ],
    correctAnswer: 0,
    explanation:
      "Short-circuit evaluation stops processing the expression as soon as the final outcome is determined (e.g., if the first condition in an AND is false, the second is skipped).",
  },
  {
    id: "cpe301_102",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "In a standard assembly language implementation of a `WHILE` loop, where is the conditional jump typically placed?",
    options: [
      "At the top (before the body) and potentially an unconditional jump at the bottom",
      "Only at the very bottom of the loop",
      "In the middle of the loop body",
      "WHILE loops cannot be implemented in assembly",
    ],
    correctAnswer: 0,
    explanation:
      "A WHILE loop is a pre-test loop. It checks the condition at the top; if false, it jumps to the end. At the bottom, an unconditional jump usually returns to the top.",
  },
  {
    id: "cpe301_103",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which of the following best describes 'Table-Driven Selection'?",
    options: [
      "Using a loop to compare a value against a long list of constants",
      "Using a data structure containing lookup values and procedure offsets to direct control flow",
      "Using the `.IF` directive multiple times",
      "Using the stack to store selection variables",
    ],
    correctAnswer: 1,
    explanation:
      "Table-driven selection avoids long chains of comparisons by looking up a value in a table and jumping to the corresponding procedure address stored in the table.",
  },
  {
    id: "cpe301_104",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "When implementing a logical OR operation `if (A > B) OR (C > D)`, if the first condition `(A > B)` is True, what should the code do?",
    options: [
      "Immediately execute the 'True' block (short-circuit)",
      "Evaluate the second condition `(C > D)` anyway",
      "Jump to the 'False' block",
      "Clear the Carry Flag",
    ],
    correctAnswer: 0,
    explanation:
      "In a logical OR, if the first condition is true, the entire expression is true. Short-circuit logic jumps immediately to the code block for the True case.",
  },
  {
    id: "cpe301_105",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: Table-driven selection is generally slower than using a long series of Compare and Jump instructions for large sets of conditions.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 2,
    explanation:
      "False. Table-driven selection is typically faster (O(1) lookup) compared to a linear chain of comparisons (O(n)) for large sets.",
  },
  {
    id: "cpe301_106",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which logic gate concept is applied when checking if a value is within a range (e.g., `val >= 10` AND `val <= 20`)?",
    options: ["Boolean OR", "Boolean AND", "Boolean XOR", "Boolean NOT"],
    correctAnswer: 1,
    explanation:
      "Checking a range requires the value to satisfy both lower bound AND upper bound conditions simultaneously.",
  },

  // SECTION 6.6: Finite-State Machines (FSM)
  {
    id: "cpe301_107",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "In the context of a Finite-State Machine (FSM), what constitutes a 'transition'?",
    options: [
      "Changing from one state to another triggered by an input",
      "Defining a variable",
      "Allocating memory for the graph",
      "The termination of the program",
    ],
    correctAnswer: 0,
    explanation:
      "A transition is the movement from one state to another, usually triggered by a specific input event.",
  },
  {
    id: "cpe301_108",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which of the following applications is well-suited for a Finite-State Machine?",
    options: [
      "Validating the format of a signed integer string",
      "Adding two large arrays",
      "Copying a string",
      "Clearing a register",
    ],
    correctAnswer: 0,
    explanation:
      "FSMs are excellent for parsing and validating input strings where the validity of the next character depends on the current parsing state (e.g., sign, digits).",
  },
  {
    id: "cpe301_109",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "In a directed graph representing an FSM, what do the nodes represent?",
    options: ["Transitions", "States", "Inputs", "Outputs"],
    correctAnswer: 1,
    explanation:
      "Nodes represent States, and the edges (lines) between them represent Transitions.",
  },
  {
    id: "cpe301_110",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If an FSM for signed integers encounters a digit while in the 'Start' state (no sign read yet), what should be the next state?",
    options: ["Error State", "Sign State", "Digit State", "End State"],
    correctAnswer: 2,
    explanation:
      "If a digit is found immediately, the FSM transitions directly to the state handling digits (skipping the optional sign state).",
  },

  // SECTION 6.7: Conditional Control Flow Directives (MASM)
  {
    id: "cpe301_111",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which MASM directive is used to generate runtime logic for a standard If-Else structure?",
    options: ["IF / ELSE", ".IF / .ELSE", "##IF / ##ELSE", "&IF / &ELSE"],
    correctAnswer: 1,
    explanation:
      "MASM uses the dot-prefix directives `.IF`, `.ELSE`, `.ELSEIF`, and `.ENDIF` for runtime conditional code generation.",
  },
  {
    id: "cpe301_112",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What code does the assembler automatically generate for the `.IF` directive?",
    options: [
      "It calls a C library function.",
      "It generates `CMP` (or `TEST`) instructions followed by Conditional Jumps.",
      "It creates a macro.",
      "It interprets the code at runtime without compiling.",
    ],
    correctAnswer: 1,
    explanation:
      "The assembler translates `.IF` directives into the corresponding low-level comparison and conditional jump instructions.",
  },
  {
    id: "cpe301_113",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which relational operator is used in MASM directives to check for equality?",
    options: ["=", "==", "EQ", ":="],
    correctAnswer: 1,
    explanation:
      "MASM directives use the C-style `==` operator for equality checks (e.g., `.IF eax == 10`).",
  },
  {
    id: "cpe301_114",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: The `.REPEAT` block tests the condition at the *beginning* of the loop.",
    options: ["False", "True", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation:
      "False. `.REPEAT` ... `.UNTIL` creates a post-test loop, checking the condition at the end (similar to do-while).",
  },
  {
    id: "cpe301_115",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which directive allows you to exit a `.WHILE` loop before the condition becomes false?",
    options: [".EXIT", ".QUIT", ".BREAK", ".STOP"],
    correctAnswer: 2,
    explanation:
      "The `.BREAK` directive generates an unconditional jump to the instruction immediately following the loop.",
  },
  {
    id: "cpe301_116",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "How does the assembler handle signed vs. unsigned comparisons in `.IF` directives?",
    options: [
      "It always uses signed jumps.",
      "It always uses unsigned jumps.",
      "It determines the type based on context (e.g., variable types) or specific operators.",
      "It requires the user to manually write the jump instruction.",
    ],
    correctAnswer: 2,
    explanation:
      "MASM checks the type of the operands (e.g., SDWORD vs DWORD) to generate the correct jump (e.g., `JG` vs `JA`).",
  },
  {
    id: "cpe301_117",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which symbol represents the logical NOT operator in MASM conditional directives?",
    options: ["~", "!", "NOT", "-"],
    correctAnswer: 1,
    explanation:
      "The `!` symbol is used for logical NOT (e.g., `.IF !(eax > 0)`).",
  },
  {
    id: "cpe301_118",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "The `.CONTINUE` directive is used to:",
    options: [
      "Jump to the top of the loop to evaluate the condition.",
      "Continue execution to the next line of code.",
      "Exit the program.",
      "Define a constant.",
    ],
    correctAnswer: 0,
    explanation:
      "`.CONTINUE` skips the rest of the loop body and jumps to the loop's condition check.",
  },
  {
    id: "cpe301_119",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which condition code can be used in an `.IF` statement to check if the Carry Flag is set?",
    options: ["CARRY", "CARRY?", "CF", "IS_CARRY"],
    correctAnswer: 1,
    explanation:
      "MASM provides the `CARRY?` symbol to check the state of the Carry flag.",
  },
  {
    id: "cpe301_120",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What is the equivalent low-level logic for `.WHILE EAX > 0`?",
    options: [
      "Label at top, CMP EAX 0, JNG to End, Body, JMP to top",
      "Body, CMP EAX 0, JG to top",
      "CMP EAX 0, Body, LOOP",
      "None of the above",
    ],
    correctAnswer: 0,
    explanation:
      "A WHILE loop checks first. If EAX is NOT greater than 0 (JNG), it jumps to the end. Otherwise, it executes the body and jumps back to the top.",
  },

  // MIXED APPLICATIONS & SCENARIOS
  {
    id: "cpe301_121",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If you need to encrypt a byte using symmetric encryption, which instruction is most commonly used?",
    options: ["AND", "OR", "XOR", "NOT"],
    correctAnswer: 2,
    explanation:
      "XOR is used for symmetric encryption because `(A XOR Key) XOR Key = A`. It is reversible.",
  },
  {
    id: "cpe301_122",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Checking if a character in AL is a printable ASCII character (20h to 7Eh) requires:",
    options: [
      "Checking if AL >= 20h OR AL <= 7Eh",
      "Checking if AL >= 20h AND AL <= 7Eh",
      "Checking if AL == 20h",
      "Checking if AL > 7Fh",
    ],
    correctAnswer: 1,
    explanation:
      "A range check requires the value to be greater/equal to the minimum AND less/equal to the maximum.",
  },
  {
    id: "cpe301_123",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: The `.ELSEIF` directive must always be followed by an `.ELSE` block.",
    options: ["Maybe", "True", "False", "I don't know"],
    correctAnswer: 2,
    explanation: "False. `.ELSEIF` can exist without a final `.ELSE` block.",
  },
  {
    id: "cpe301_124",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction sequence effectively implements `if (EAX == 0)` without using `CMP`?",
    options: [
      "OR EAX, EAX / JZ target",
      "MOV EAX, 0 / JZ target",
      "ADD EAX, 1 / JNZ target",
      "NOT EAX / JS target",
    ],
    correctAnswer: 0,
    explanation:
      "`OR EAX, EAX` sets the Zero Flag if EAX is zero without changing EAX. JZ then jumps if ZF is set.",
  },
  {
    id: "cpe301_125",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What logic does the `.UNTIL` directive generate?",
    options: [
      "It jumps back to the start of the loop if the condition is False",
      "It jumps back to the start of the loop if the condition is True",
      "It always jumps back",
      "It never jumps",
    ],
    correctAnswer: 0,
    explanation:
      "`REPEAT` ... `UNTIL (Condition)` implies 'Repeat *until* the condition becomes True'. Therefore, it loops (jumps back) while the condition is False.",
  },
  {
    id: "cpe301_126",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Using `TEST AL, 10000000b` helps determine:",
    options: [
      "If the number is zero",
      "If the number is even",
      "If the most significant bit (Sign bit) is set",
      "If the number is a multiple of 4",
    ],
    correctAnswer: 2,
    explanation:
      "10000000b masks bit 7. If ZF=0 (result non-zero), bit 7 is set, indicating a negative number (in signed interpretation) or high bit set.",
  },
  {
    id: "cpe301_127",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which operator is used for Logical OR in MASM directives?",
    options: ["|", "||", "OR", "AND"],
    correctAnswer: 1,
    explanation:
      "The `||` operator represents logical OR in MASM directives (e.g., `.IF (eax==1) || (eax==2)`).",
  },
  {
    id: "cpe301_128",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: Using `.IF` directives makes the assembled machine code significantly larger and slower than writing `CMP/JMP` manually.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 2,
    explanation:
      "False. MASM generates efficient `CMP` and `JMP` instructions. While manual optimization *can* be better in edge cases, the generated code is standard and not inherently 'bloated'.",
  },
  {
    id: "cpe301_129",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To check if the Overflow flag is set using high-level directives, use:",
    options: [".IF OVERFLOW?", ".IF OF", ".IF O?", ".IF OVF"],
    correctAnswer: 0,
    explanation: "`OVERFLOW?` is the condition code for the Overflow Flag.",
  },
  {
    id: "cpe301_130",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "When scanning a string for a null terminator (0), which loop structure is most efficient and typical?",
    options: [
      "A fixed-count LOOP",
      "A conditional loop checking for 0",
      "A table-driven jump",
      "A single CMP instruction",
    ],
    correctAnswer: 1,
    explanation:
      "Strings vary in length, so you must use a conditional loop (like `.WHILE` or `JNZ`) checking for the terminator.",
  },
  {
    id: "cpe301_131",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction can check if a specific bit is 1 and set the Zero flag accordingly (ZF=0 if bit is 1)?",
    options: ["CMP", "TEST", "MOV", "SETZ"],
    correctAnswer: 1,
    explanation:
      "TEST performs an AND. If the bit is 1, `1 AND 1 = 1` (Non-Zero result), so ZF is cleared (0).",
  },
  {
    id: "cpe301_132",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If you need to define a complex condition `if ((A==B) && (C!=D))`, which technique reduces CPU cycles?",
    options: [
      "Evaluating both sides fully and storing results",
      "Short-circuiting: If A!=B, do not check C!=D",
      "Using the stack to compare",
      "Using Floating Point registers",
    ],
    correctAnswer: 1,
    explanation:
      "Short-circuiting prevents unnecessary execution of the second comparison if the first one already determines the failure of the AND block.",
  },
  {
    id: "cpe301_133",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "In a Finite-State Machine, the 'Default' state often handles:",
    options: [
      "The successful completion of the task",
      "Invalid or unexpected input",
      "The start of the program",
      "Memory allocation",
    ],
    correctAnswer: 1,
    explanation:
      "Typically, if an input does not match any valid transition for the current state, the FSM goes to a Default/Error state.",
  },
  {
    id: "cpe301_134",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "The `SETc` instruction sets the destination byte to 1 if:",
    options: [
      "The Counter is zero",
      "The Carry Flag is set",
      "The Condition is false",
      "The Compare is true",
    ],
    correctAnswer: 1,
    explanation: "SETc stands for Set if Carry (CF=1).",
  },
  {
    id: "cpe301_135",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To implement `if (eax != 0)` efficiently, which instruction sequence is preferred?",
    options: [
      "CMP EAX, 1 / JGE target",
      "TEST EAX, EAX / JNZ target",
      "MOV EBX, 0 / CMP EAX, EBX",
      "ADD EAX, 0 / JZ target",
    ],
    correctAnswer: 1,
    explanation:
      "`TEST EAX, EAX` updates flags without modifying EAX and is generally faster/smaller than comparing with immediates or other registers.",
  },
  {
    id: "cpe301_136",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which operator represents Logical AND in MASM directives?",
    options: ["&", "&&", "AND", "^"],
    correctAnswer: 1,
    explanation: "`&&` is the logical AND operator in MASM directives.",
  },
  {
    id: "cpe301_137",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: A `WHILE` loop is guaranteed to execute its body at least once.",
    options: ["True", "Maybe", "False", "I don't know"],
    correctAnswer: 2,
    explanation:
      "False. A WHILE loop checks the condition *before* entering the body. If the condition is initially false, the body never executes.",
  },
  {
    id: "cpe301_138",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To force an odd number to be even, you can use:",
    options: ["OR AL, 1", "AND AL, 11111110b", "XOR AL, 1", "TEST AL, 0"],
    correctAnswer: 1,
    explanation:
      "Clearing the least significant bit (bit 0) ensures the number is even. `AND` with a mask ending in 0 achieves this.",
  },
  {
    id: "cpe301_139",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If `CMP` results in `CF=1` (Unsigned comparison), it means:",
    options: [
      "Destination > Source",
      "Destination == Source",
      "Destination < Source",
      "Overflow occurred",
    ],
    correctAnswer: 2,
    explanation:
      "In unsigned subtraction (CMP), a Borrow (Carry=1) occurs if you subtract a larger number from a smaller one (Dest < Source).",
  },
  {
    id: "cpe301_140",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "The `.REPEAT` directive corresponds to which C++ construct?",
    options: [
      "while() { ... }",
      "do { ... } while();",
      "for() { ... }",
      "if() { ... }",
    ],
    correctAnswer: 1,
    explanation:
      "`.REPEAT` ... `.UNTIL` is a post-test loop, functioning exactly like `do ... while`.",
  },
  {
    id: "cpe301_141",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "When validating input with an FSM, a 'Terminal State' usually indicates:",
    options: [
      "The program crashed",
      "The input is valid and parsing is complete",
      "The input is invalid",
      "The CPU is overheating",
    ],
    correctAnswer: 1,
    explanation:
      "A terminal (or accepting) state is reached when the input string satisfies the validation rules.",
  },
  {
    id: "cpe301_142",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction can copy the Carry Flag into the lower bit of a register?",
    options: ["ADC", "SBB", "SETC", "MOV"],
    correctAnswer: 2,
    explanation:
      "SETC (Set if Carry) sets the byte operand to 1 if CF=1, and 0 otherwise.",
  },
  {
    id: "cpe301_143",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To convert a digit '5' (ASCII 35h) to integer 5, you can:",
    options: ["AND AL, 0Fh", "OR AL, 30h", "ADD AL, 30h", "XOR AL, FFh"],
    correctAnswer: 0,
    explanation:
      "ASCII digits '0'-'9' are 30h-39h. Masking the upper nibble (AND with 0Fh) leaves just the binary value (0-9).",
  },
  {
    id: "cpe301_144",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: The `.BREAK .IF` syntax is valid in MASM to exit a loop conditionally.",
    options: ["Maybe", "False", "True", "I don't know"],
    correctAnswer: 2,
    explanation:
      "True. MASM allows `.BREAK .IF condition` to combine the check and break.",
  },
  {
    id: "cpe301_145",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "De Morgan's Laws are often used in assembly to:",
    options: [
      "Increase the size of the code",
      "Simplify complex compound boolean expressions",
      "Perform floating point math",
      "Encrypt data",
    ],
    correctAnswer: 1,
    explanation:
      "De Morgan's laws allow converting AND logic to OR logic (and vice versa) with negation, often simplifying the branching structure.",
  },
  {
    id: "cpe301_146",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction effectively divides an unsigned number by 2?",
    options: ["SHL", "SHR", "ROL", "ROR"],
    correctAnswer: 1,
    explanation: "Logical Shift Right (SHR) divides an unsigned integer by 2.",
  },
  {
    id: "cpe301_147",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "In a 'While' loop implementation, the unconditional Jump at the bottom targets:",
    options: [
      "The instruction immediately following the loop",
      "The top of the loop (condition check)",
      "The middle of the loop",
      "The ExitProcess",
    ],
    correctAnswer: 1,
    explanation:
      "After executing the body, the loop must jump back to the top to re-evaluate the condition.",
  },
  {
    id: "cpe301_148",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If `SF=1` and `OF=1` after a CMP, what is the result (Signed)?",
    options: ["Less Than", "Greater Than", "Equal", "Zero"],
    correctAnswer: 1,
    explanation:
      "Signed Less Than is `SF != OF`. Since `1 == 1` (SF == OF), it is NOT Less Than. It is Greater Than (or Equal).",
  },
  {
    id: "cpe301_149",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which directive checks for the Parity flag?",
    options: [".IF PARITY?", ".IF P?", ".IF PE", ".IF PAR"],
    correctAnswer: 0,
    explanation: "`PARITY?` is the condition code for the Parity Flag.",
  },
  {
    id: "cpe301_150",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What is the primary advantage of using `.IF` directives over manual CMP/JMP?",
    options: [
      "Faster execution speed",
      "Improved code readability and maintainability",
      "Smaller binary size",
      "Direct hardware access",
    ],
    correctAnswer: 1,
    explanation:
      "Directives abstract the low-level jump logic, making the source code easier for humans to read and maintain, similar to high-level languages.",
  },
  {
    id: "cpe301_151",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To check if a number is strictly between 50 and 100 (`50 < val < 100`), you need:",
    options: ["OR logic", "XOR logic", "AND logic", "NOT logic"],
    correctAnswer: 2,
    explanation: "The value must be greater than 50 AND less than 100.",
  },
  {
    id: "cpe301_152",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: `TEST` modifies the destination operand.",
    options: ["True", "Maybe", "I don't know", "False"],
    correctAnswer: 3,
    explanation: "False. `TEST` performs a non-destructive AND.",
  },
  {
    id: "cpe301_153",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction can test specific bits and set the Zero flag, but preserves the operand?",
    options: ["AND", "TEST", "OR", "XOR"],
    correctAnswer: 1,
    explanation:
      "TEST is the only option that updates flags based on bitwise logic without storing the result.",
  },
  {
    id: "cpe301_154",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "When implementing `if( EAX >= 10 )`, which conditional jump skips the body (jumps to Else/End)?",
    options: ["JGE", "JL (Jump Less)", "JA", "JZ"],
    correctAnswer: 1,
    explanation:
      "If the logic is `If >= 10, then Do X`, the assembly implementation usually says `If < 10, Jump Over X`. So `JL` (Jump Less) is used to skip the body.",
  },
  {
    id: "cpe301_155",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What does `Jcxz` stand for?",
    options: [
      "Jump if Counter is Zero",
      "Jump if CX is Zero",
      "Jump if Condition X is Zero",
      "Jump if Carry X Zero",
    ],
    correctAnswer: 1,
    explanation: "Jump if CX register is Zero.",
  },
  {
    id: "cpe301_156",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which logic is used to convert an ASCII digit string to an integer?",
    options: [
      "Shift Left and Add",
      "Shift Right and Subtract",
      "Rotate and XOR",
      "Not possible in assembly",
    ],
    correctAnswer: 0,
    explanation:
      "To convert string to int: Multiply current total by 10 (Shift/Add) and add the new digit.",
  },
  {
    id: "cpe301_157",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If `EAX` is 1, what is the value of `EAX` after `.IF EAX > 0 ... .ENDIF`?",
    options: ["0", "1", "2", "Undefined"],
    correctAnswer: 1,
    explanation:
      "The `.IF` directive affects control flow but does not modify the registers being tested (unlike some side-effect operations).",
  },
  {
    id: "cpe301_158",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Using `XOR` to zero a register is preferred over `MOV Reg, 0` because:",
    options: [
      "It is easier to read",
      "It typically requires fewer bytes of machine code",
      "It doesn't affect flags",
      "It allows memory operands",
    ],
    correctAnswer: 1,
    explanation:
      "`XOR EAX, EAX` is a standard optimization that is smaller (and often faster) than `MOV EAX, 0`.",
  },
  {
    id: "cpe301_159",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which directive checks the Sign Flag?",
    options: [".IF NEGATIVE", ".IF SIGN?", ".IF S", ".IF SF"],
    correctAnswer: 1,
    explanation: "`SIGN?` is the condition code for the Sign Flag.",
  },
  {
    id: "cpe301_160",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "In a boolean expression `A AND B`, if A is false, B is:",
    options: [
      "Evaluated anyway",
      "Skipped (in short-circuit evaluation)",
      "Inverted",
      "Set to 0",
    ],
    correctAnswer: 1,
    explanation:
      "If A is false, `False AND B` is always False, so B is skipped.",
  },
  {
    id: "cpe301_161",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "What is a major benefit of the `BT` instruction over `TEST`?",
    options: [
      "It allows selecting a bit by a variable index",
      "It is faster",
      "It modifies the destination",
      "It works on strings",
    ],
    correctAnswer: 0,
    explanation:
      "`BT` can take a register as the bit index, allowing dynamic selection of the bit to test. `TEST` usually requires a fixed mask or creating one.",
  },
  {
    id: "cpe301_162",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: The `.EXIT` directive generates code to terminate the program.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation:
      "True. `.EXIT` generates the exit sequence (usually calling ExitProcess).",
  },
  {
    id: "cpe301_163",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If `EAX` contains -1 and `EBX` contains 1, `CMP EAX, EBX` followed by `JG` will:",
    options: ["Jump (Taken)", "Not Jump (Not Taken)", "Crash", "Set ZF"],
    correctAnswer: 1,
    explanation: "-1 is NOT greater than 1. JG (Signed Greater) will not jump.",
  },
  {
    id: "cpe301_164",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "If `EAX` contains -1 and `EBX` contains 1, `CMP EAX, EBX` followed by `JA` will:",
    options: ["Jump (Taken)", "Not Jump (Not Taken)", "Crash", "Set ZF"],
    correctAnswer: 0,
    explanation:
      "-1 is FFFFFFFFh. 1 is 00000001h. Unsigned `JA` sees FFFFFFFF > 00000001. Jump Taken.",
  },
  {
    id: "cpe301_165",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction is necessary to clear the direction flag (for forward string operations)?",
    options: ["CLD", "STD", "CLI", "STI"],
    correctAnswer: 0,
    explanation: "CLD (Clear Direction Flag).",
  },
  {
    id: "cpe301_166",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Bitwise XORing a value with itself produces:",
    options: ["All 1s", "All 0s", "The original value", "Inverted value"],
    correctAnswer: 1,
    explanation: "A XOR A = 0.",
  },
  {
    id: "cpe301_167",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Bitwise ANDing a value with 0 produces:",
    options: ["All 0s", "All 1s", "The original value", "Inverted value"],
    correctAnswer: 0,
    explanation: "A AND 0 = 0.",
  },
  {
    id: "cpe301_168",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Bitwise ORing a value with 0 produces:",
    options: ["All 0s", "All 1s", "The original value", "Inverted value"],
    correctAnswer: 2,
    explanation: "A OR 0 = A.",
  },
  {
    id: "cpe301_169",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which directive creates a runtime loop that executes at least once?",
    options: [".WHILE", ".REPEAT", ".IF", ".LOOP"],
    correctAnswer: 1,
    explanation:
      "`.REPEAT` ... `.UNTIL` puts the check at the end, guaranteeing at least one execution.",
  },
  {
    id: "cpe301_170",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "In 64-bit mode, the `TEST` instruction can operate on:",
    options: [
      "64-bit registers",
      "Only 32-bit registers",
      "Only 16-bit registers",
      "Only 8-bit registers",
    ],
    correctAnswer: 0,
    explanation: "64-bit mode supports 64-bit operands for logic instructions.",
  },
  {
    id: "cpe301_171",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To jump if `(unsigned) EAX <= EBX`, you use:",
    options: ["JBE", "JLE", "JNG", "JS"],
    correctAnswer: 0,
    explanation: "Jump if Below or Equal (Unsigned).",
  },
  {
    id: "cpe301_172",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "To jump if `(signed) EAX <= EBX`, you use:",
    options: ["JBE", "JLE", "JNA", "JC"],
    correctAnswer: 1,
    explanation: "Jump if Less or Equal (Signed).",
  },
  {
    id: "cpe301_173",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Which instruction can simulate a `NOT` operation using `XOR`?",
    options: [
      "XOR Reg, 0",
      "XOR Reg, Reg",
      "XOR Reg, -1 (All 1s)",
      "XOR Reg, 1",
    ],
    correctAnswer: 2,
    explanation:
      "XOR with all 1s (FFFF... or -1) inverts every bit, equivalent to NOT.",
  },
  {
    id: "cpe301_174",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "True or False: `TEST AL, 0` sets the Zero Flag to 1.",
    options: ["True", "False", "Maybe", "I don't know"],
    correctAnswer: 0,
    explanation:
      "True. `AL AND 0` is 0. Since the result is zero, ZF is set to 1.",
  },
  {
    id: "cpe301_175",
    course: "CPE301",
    chapter: "Chapter 6",
    text: "Finite State Machines are most commonly represented visually by:",
    options: ["Pie Charts", "Directed Graphs", "Histograms", "Scatter Plots"],
    correctAnswer: 1,
    explanation:
      "Directed graphs (State Diagrams) are the standard visual representation.",
  },
];

const cpe301Chapter6: QuestionV2[] = [
  ...CPE301Chapter6Part1,
  ...CPE301Chapter6Part2,
];

export default cpe301Chapter6;
