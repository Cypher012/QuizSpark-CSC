import { QuestionV2 } from "@/lib/quiz-types";

export const cpe301Chapter2: QuestionV2[] = [
  {
    id: "cpe301_001",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What are the three basic operations in the instruction execution cycle?",
    options: [
      "Load, Store, Execute",
      "Fetch, Decode, Execute",
      "Read, Write, Process",
      "Input, Process, Output",
    ],
    correctAnswer: 1,
    explanation:
      "The instruction execution cycle consists of three basic operations: Fetch (retrieve instruction from memory), Decode (interpret the instruction), and Execute (perform the operation).",
  },
  {
    id: "cpe301_002",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What is the purpose of the clock in a CPU?",
    options: [
      "To display the current time",
      "To synchronize internal operations of the CPU",
      "To count the number of instructions executed",
      "To manage power consumption",
    ],
    correctAnswer: 1,
    explanation:
      "The clock generates timing signals that synchronize all internal CPU operations.",
  },
  {
    id: "cpe301_003",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What is a bus in computer architecture?",
    options: [
      "A vehicle for transporting data",
      "A group of parallel wires that transfer data",
      "A type of memory storage",
      "A processing unit",
    ],
    correctAnswer: 1,
    explanation:
      "A bus is a group of parallel electrical conductors (wires) used to transfer data between computer components.",
  },
  {
    id: "cpe301_004",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What is a machine cycle also known as?",
    options: ["Instruction cycle", "Clock cycle", "Memory cycle", "Bus cycle"],
    correctAnswer: 1,
    explanation:
      "A machine cycle is also called a clock cycle - the time between two pulses of the system clock.",
  },
  {
    id: "cpe301_005",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What are wait states in the instruction execution cycle?",
    options: [
      "Pauses for user input",
      "Empty clock cycles due to speed differences between CPU and memory",
      "Periods of system hibernation",
      "Interrupts from the operating system",
    ],
    correctAnswer: 1,
    explanation:
      "Wait states are empty clock cycles inserted when the CPU must wait for slower memory or I/O devices.",
  },
  {
    id: "cpe301_006",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What are the three primary modes of operation for x86 processors?",
    options: [
      "User, Kernel, Supervisor",
      "Real, Virtual, Protected",
      "Protected, Real-address, System management",
      "Execution, Protected, Virtual",
    ],
    correctAnswer: 2,
    explanation:
      "The three primary modes are Protected mode, Real-address mode, and System Management Mode (SMM).",
  },
  {
    id: "cpe301_007",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What is the maximum amount of memory accessible in Real-address mode?",
    options: ["64 KB", "640 KB", "1 MB", "4 GB"],
    correctAnswer: 2,
    explanation:
      "Real-address mode can access up to 1 MB of memory using 20-bit addresses.",
  },
  {
    id: "cpe301_008",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What is the primary purpose of System Management Mode (SMM)?",
    options: [
      "To run legacy DOS applications",
      "To implement operating system functions",
      "To implement power management and system security",
      "To provide virtual memory support",
    ],
    correctAnswer: 2,
    explanation:
      "SMM provides an operating system with mechanisms for power management and system security.",
  },
  {
    id: "cpe301_009",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "Which Intel processor was the first to support Protected mode?",
    options: ["Intel 8086", "Intel 80286", "Intel 80386", "Intel 80486"],
    correctAnswer: 1,
    explanation:
      "The Intel 80286 introduced Protected mode with memory protection features.",
  },
  {
    id: "cpe301_010",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "All segments are mapped to the entire 32-bit physical address space",
    options: [
      "Encryption",
      "Segment protection",
      "Memory locks",
      "Virtual addressing",
    ],
    correctAnswer: 1,
    explanation:
      "Segment protection prevents programs from accessing data in other segments, protecting system resources.",
  },
  {
    id: "cpe301_011",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "A mechanism that allows a segment to be divided into 4096-byte blocks of memory",
    options: ["4 GB", "16 GB", "16 exabytes", "Unlimited"],
    correctAnswer: 2,
    explanation:
      "64-bit processors can theoretically address 2^64 bytes = 16 exabytes of memory.",
  },
  {
    id: "cpe301_012",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "In 64-bit mode, what is the default operand size?",
    options: ["16 bits", "32 bits", "64 bits", "128 bits"],
    correctAnswer: 1,
    explanation:
      "In 64-bit mode, the default operand size is 32 bits unless explicitly overridden.",
  },
  {
    id: "cpe301_013",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What is compatibility mode in x86-64 processors?",
    options: [
      "A mode that runs 16-bit programs",
      "A sub-mode of Long mode that permits legacy 32-bit programs to run",
      "A mode for backward compatibility with 8086",
      "A mode that emulates other processor types",
    ],
    correctAnswer: 1,
    explanation:
      "Compatibility mode is a sub-mode of Long mode that allows 32-bit applications to run on 64-bit systems.",
  },
  {
    id: "cpe301_014",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What does the chipset do in a microcomputer?",
    options: [
      "Provides power to the CPU",
      "Contains the BIOS",
      "Controls the flow of data between CPU, memory, and peripherals",
      "Stores the operating system",
    ],
    correctAnswer: 2,
    explanation:
      "The chipset manages data flow and communication between the processor, memory, and peripheral devices.",
  },
  {
    id: "cpe301_015",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What type of memory is the CPU cache?",
    options: ["ROM", "SRAM (Static RAM)", "DRAM (Dynamic RAM)", "Flash memory"],
    correctAnswer: 1,
    explanation:
      "CPU cache uses SRAM, which is faster but more expensive than DRAM.",
  },
  {
    id: "cpe301_016",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What does USB stand for?",
    options: [
      "Universal System Bus",
      "Universal Serial Bus",
      "Unified Storage Bus",
      "Universal Synchronous Bus",
    ],
    correctAnswer: 1,
    explanation:
      "USB stands for Universal Serial Bus, a standard for connecting peripherals.",
  },
  {
    id: "cpe301_017",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What is the purpose of the system clock generator?",
    options: [
      "To keep track of time",
      "To provide timing signals to synchronize system components",
      "To generate random numbers",
      "To control the power supply",
    ],
    correctAnswer: 1,
    explanation:
      "The clock generator produces timing signals that synchronize all system operations.",
  },
  {
    id: "cpe301_018",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What information is typically stored in CMOS memory?",
    options: [
      "The operating system",
      "System configuration information and hardware settings",
      "User documents",
      "Application programs",
    ],
    correctAnswer: 1,
    explanation:
      "CMOS stores system configuration data like date/time, boot order, and hardware settings.",
  },
  {
    id: "cpe301_019",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "Which level of I/O provides the fastest access but requires detailed hardware knowledge?",
    options: [
      "High-level language functions",
      "Operating system functions",
      "BIOS functions",
      "Hardware level",
    ],
    correctAnswer: 3,
    explanation:
      "Direct hardware-level access is fastest but requires detailed knowledge of hardware ports and protocols.",
  },
  {
    id: "cpe301_020",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "How are BIOS functions typically called in assembly language?",
    options: [
      "Using CALL instructions",
      "Using software interrupts (INT instruction)",
      "Using jump instructions",
      "Using procedure calls",
    ],
    correctAnswer: 1,
    explanation:
      "BIOS functions are invoked using software interrupts (INT instruction) with specific interrupt numbers.",
  },
  {
    id: "cpe301_021",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "Which BIOS interrupt handles keyboard services?",
    options: ["INT 10h", "INT 16h", "INT 21h", "INT 13h"],
    correctAnswer: 1,
    explanation: "INT 16h provides keyboard services for reading keystrokes.",
  },
  {
    id: "cpe301_022",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What is the primary advantage of using high-level language I/O functions?",
    options: [
      "Faster execution",
      "Direct hardware control",
      "Portability across platforms",
      "Lower memory usage",
    ],
    correctAnswer: 2,
    explanation:
      "High-level I/O functions are portable across different platforms and easier to use.",
  },
  {
    id: "cpe301_023",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "It's slow and not suitable for graphical applications",
    options: [
      "Direct hardware access",
      "BIOS interrupts",
      "Operating system API calls",
      "Assembly language only",
    ],
    correctAnswer: 2,
    explanation:
      "Protected mode OSes use API calls to perform I/O through device drivers, not direct BIOS access.",
  },
  {
    id: "cpe301_024",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "If a segment register contains 0300h and the offset is 0040h, what is the linear address?",
    options: ["0340h", "3040h", "3400h", "3000h"],
    correctAnswer: 1,
    explanation: "Linear address = (0300h Ã— 16) + 0040h = 3000h + 40h = 3040h",
  },
  {
    id: "cpe301_025",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "How large is a segment in Real-address mode?",
    options: ["64 KB", "128 KB", "256 KB", "1 MB"],
    correctAnswer: 0,
    explanation:
      "A segment in real-address mode is 64 KB (65,536 bytes) due to 16-bit offsets.",
  },
  {
    id: "cpe301_026",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "In Protected mode, what does a segment selector point to?",
    options: [
      "Physical memory address",
      "A descriptor table entry",
      "An offset value",
      "A page table",
    ],
    correctAnswer: 1,
    explanation:
      "A segment selector is an index into a descriptor table (GDT or LDT).",
  },
  {
    id: "cpe301_027",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What is a linear address in Protected mode?",
    options: [
      "The same as physical address",
      "A 32-bit address before paging translation",
      "The offset within a segment",
      "A 16-bit address",
    ],
    correctAnswer: 1,
    explanation:
      "A linear address is the result of segment translation, before paging translates it to physical address.",
  },
  {
    id: "cpe301_028",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What is the size of a page in x86 paging?",
    options: ["1 KB", "2 KB", "4 KB", "8 KB"],
    correctAnswer: 2,
    explanation: "Standard x86 pages are 4 KB (4096 bytes) in size.",
  },
  {
    id: "cpe301_029",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What are the 32-bit general-purpose registers?",
    options: [
      "AX, BX, CX, DX, SI, DI, BP, SP",
      "EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP",
      "RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP",
      "AL, BL, CL, DL, AH, BH, CH, DH",
    ],
    correctAnswer: 1,
    explanation:
      "The 'E' prefix denotes Extended (32-bit) registers in 32-bit x86 architecture.",
  },
  {
    id: "cpe301_030",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "Which register is commonly used as a loop counter?",
    options: ["EAX", "EBX", "ECX", "EDX"],
    correctAnswer: 2,
    explanation:
      "ECX is the count register, traditionally used as a loop counter.",
  },
  {
    id: "cpe301_031",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "Which register is used as the base pointer for stack frames?",
    options: ["ESP", "EBP", "ESI", "EDI"],
    correctAnswer: 1,
    explanation:
      "EBP (Extended Base Pointer) is used to reference local variables and parameters in a stack frame.",
  },
  {
    id: "cpe301_032",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "How can you access the lower 16 bits of EAX?",
    options: ["EAX", "AX", "AL", "AH"],
    correctAnswer: 1,
    explanation: "AX refers to the lower 16 bits of the 32-bit EAX register.",
  },
  {
    id: "cpe301_033",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "Which segment register traditionally holds the address of the current code segment?",
    options: ["DS", "SS", "CS", "ES"],
    correctAnswer: 2,
    explanation:
      "CS (Code Segment) register holds the segment selector for the code segment.",
  },
  {
    id: "cpe301_034",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "How many segment registers are there in x86 processors?",
    options: ["4", "6", "8", "16"],
    correctAnswer: 1,
    explanation: "There are 6 segment registers: CS, DS, SS, ES, FS, and GS.",
  },
  {
    id: "cpe301_035",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "What is the EFLAGS register used for?",
    options: [
      "Storing arithmetic results",
      "Containing status and control flags",
      "Addressing memory",
      "Counting iterations",
    ],
    correctAnswer: 1,
    explanation:
      "EFLAGS contains status flags (like Zero, Carry) and control flags that affect processor behavior.",
  },
  {
    id: "cpe301_036",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "When is the Zero flag (ZF) set?",
    options: [
      "When the result is negative",
      "When the result is zero",
      "When there's a carry",
      "When there's an overflow",
    ],
    correctAnswer: 1,
    explanation:
      "The Zero Flag (ZF) is set when the result of an operation is zero.",
  },
  {
    id: "cpe301_037",
    course: "CPE 301",
    chapter: "Chapter 2",
    text: "The Overflow flag (OF) is set when:",
    options: [
      "The result is zero",
      "There's a carry",
      "A signed arithmetic operation generates a result too large to fit in the destination",
      "The result is negative",
    ],
    correctAnswer: 2,
    explanation:
      "The Overflow Flag (OF) indicates signed arithmetic overflow when the result doesn't fit in the destination.",
  },
  {
    id: "cpe301_038",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Whether the lowest byte has an even or odd number of 1 bits",
    options: ["Carry flag", "Direction flag", "Trap flag", "Interrupt flag"],
    correctAnswer: 1,
    explanation:
      "The Direction Flag (DF) controls whether string operations increment (DF=0) or decrement (DF=1) index registers.",
  },
  {
    id: "cpe301_039",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What is an instruction in assembly language?",
    options: [
      "A command to the assembler",
      "A statement that is executed by the processor at runtime",
      "A memory allocation command",
      "A comment for documentation",
    ],
    correctAnswer: 1,
    explanation:
      "An instruction is a statement that becomes machine code and is executed by the processor.",
  },
  {
    id: "cpe301_040",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Which of the following is a valid identifier in assembly language?",
    options: ["123abc", "my-variable", "myVariable", "for"],
    correctAnswer: 2,
    explanation:
      "Valid identifiers must start with a letter or underscore, and cannot be reserved words. Hyphens are not allowed.",
  },
  {
    id: "cpe301_041",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Which directive is used to define a byte variable in MASM?",
    options: ["BYTE", "DB", "DWORD", "DEFINE_BYTE"],
    correctAnswer: 1,
    explanation:
      "DB (Define Byte) is used to allocate and initialize byte-sized variables.",
  },
  {
    id: "cpe301_042",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "In the instruction 'mov eax, ebx', what is 'mov'?",
    options: [
      "The destination operand",
      "The source operand",
      "The mnemonic (operation)",
      "A register name",
    ],
    correctAnswer: 2,
    explanation:
      "The mnemonic is the name of the instruction operation (MOV = move/copy data).",
  },
  {
    id: "cpe301_043",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "In the instruction 'add eax, 5', what is '5'?",
    options: [
      "A register",
      "An immediate operand (constant)",
      "A memory address",
      "A label",
    ],
    correctAnswer: 1,
    explanation:
      "An immediate operand is a constant value specified directly in the instruction.",
  },
  {
    id: "cpe301_044",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What is the purpose of a label in assembly language?",
    options: [
      "To comment code",
      "To mark a position in code or data",
      "To define a variable",
      "To import libraries",
    ],
    correctAnswer: 1,
    explanation:
      "Labels mark memory locations and are used as jump targets or to reference data.",
  },
  {
    id: "cpe301_045",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does the .DATA directive indicate?",
    options: [
      "The start of executable code",
      "The start of the data segment for variables",
      "The start of the stack",
      "The end of the program",
    ],
    correctAnswer: 1,
    explanation:
      "The .DATA directive begins the data segment where variables are defined.",
  },
  {
    id: "cpe301_046",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Which instruction is used to transfer data between registers or from memory to register?",
    options: ["ADD", "SUB", "MOV", "XOR"],
    correctAnswer: 2,
    explanation:
      "MOV (move) instruction copies data from source to destination.",
  },
  {
    id: "cpe301_047",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does the ADD instruction do?",
    options: [
      "Multiplies two operands",
      "Adds the source operand to the destination operand",
      "Subtracts the source from destination",
      "Compares two operands",
    ],
    correctAnswer: 1,
    explanation: "ADD performs: destination = destination + source.",
  },
  {
    id: "cpe301_048",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Can you move data directly from one memory location to another using a single MOV instruction?",
    options: [
      "Yes, always",
      "No, you must use a register as an intermediary",
      "Yes, but only in protected mode",
      "Yes, but only for byte-sized data",
    ],
    correctAnswer: 1,
    explanation:
      "x86 does not allow memory-to-memory moves; you must use a register as intermediate storage.",
  },
  {
    id: "cpe301_049",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What happens when you execute 'add eax, eax'?",
    options: [
      "EAX is cleared to zero",
      "EAX is doubled",
      "EAX remains unchanged",
      "An error occurs",
    ],
    correctAnswer: 1,
    explanation:
      "ADD EAX, EAX performs EAX = EAX + EAX, which doubles the value.",
  },
  {
    id: "cpe301_050",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "After 'mov eax, 10' and 'sub eax, 3', what is in EAX?",
    options: ["3", "7", "10", "13"],
    correctAnswer: 1,
    explanation: "EAX starts with 10, then 3 is subtracted: 10 - 3 = 7.",
  },
  {
    id: "cpe301_051",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What is the file extension for an assembly source file in MASM?",
    options: [".exe", ".obj", ".asm", ".lst"],
    correctAnswer: 2,
    explanation: "Assembly source files typically have the .asm extension.",
  },
  {
    id: "cpe301_052",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What is the typical extension of an object file?",
    options: [".exe", ".obj or .o", ".asm", ".dll"],
    correctAnswer: 1,
    explanation:
      "Object files use .obj (Windows) or .o (Unix/Linux) extensions.",
  },
  {
    id: "cpe301_053",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Combines object files and libraries into an executable",
    options: [".obj", ".asm", ".exe", ".com"],
    correctAnswer: 2,
    explanation: "Windows executables typically have the .exe extension.",
  },
  {
    id: "cpe301_054",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "A file showing source code, machine code, and addresses",
    options: [".lst", ".txt", ".log", ".out"],
    correctAnswer: 0,
    explanation: "Listing files commonly use the .lst extension.",
  },
  {
    id: "cpe301_055",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What is the purpose of a make file or build script?",
    options: [
      "To write source code",
      "To automate the assembly and linking process",
      "To debug programs",
      "To create documentation",
    ],
    correctAnswer: 1,
    explanation:
      "Make files automate the build process, specifying how to compile and link the program.",
  },
  {
    id: "cpe301_056",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Which directive defines a byte (8-bit) variable?",
    options: ["DW", "DD", "DB", "DQ"],
    correctAnswer: 2,
    explanation: "DB (Define Byte) allocates 1 byte of storage.",
  },
  {
    id: "cpe301_057",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "How many bytes does DD (Define Doubleword) allocate?",
    options: ["1 byte", "2 bytes", "4 bytes", "8 bytes"],
    correctAnswer: 2,
    explanation: "DD (Define Doubleword) allocates 4 bytes (32 bits).",
  },
  {
    id: "cpe301_058",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does the following define? 'value DB 25'",
    options: [
      "A word variable initialized to 25",
      "A byte variable initialized to 25",
      "A doubleword variable initialized to 25",
      "An array of 25 bytes",
    ],
    correctAnswer: 1,
    explanation: "DB defines a byte-sized variable with initial value 25.",
  },
  {
    id: "cpe301_059",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does 'DUP' do in a data definition?",
    options: [
      "Duplicates the variable name",
      "Creates multiple copies of the initial value",
      "Defines an unsigned pointer",
      "Declares a user procedure",
    ],
    correctAnswer: 1,
    explanation:
      "DUP (duplicate) operator repeats a value or pattern a specified number of times.",
  },
  {
    id: "cpe301_060",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "How do you define a string in MASM?",
    options: [
      "Using DB with quoted text",
      "Using STRING directive",
      "Using DW with quoted text",
      "Strings cannot be defined in assembly",
    ],
    correctAnswer: 0,
    explanation: "Strings are defined using DB with text in quotes: DB 'Hello'",
  },
  {
    id: "cpe301_061",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What is the purpose of the EQU directive?",
    options: [
      "To allocate memory",
      "To create a symbolic constant",
      "To define a procedure",
      "To end a program",
    ],
    correctAnswer: 1,
    explanation:
      "EQU (equate) creates a symbolic constant that the assembler replaces with its value.",
  },
  {
    id: "cpe301_062",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What is the difference between EQU and = in MASM?",
    options: [
      "There is no difference",
      "EQU cannot be redefined, = can be",
      "= cannot be redefined, EQU can be",
      "EQU is for numbers, = is for strings",
    ],
    correctAnswer: 1,
    explanation:
      "EQU creates permanent constants. The = operator allows redefinition of symbols.",
  },
  {
    id: "cpe301_063",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does REAL8 define?",
    options: [
      "An 8-bit real number",
      "An 8-byte (64-bit) double-precision real number",
      "An 8-element array",
      "An 8-bit integer",
    ],
    correctAnswer: 1,
    explanation:
      "REAL8 defines a double-precision floating-point number (8 bytes, 64 bits).",
  },
  {
    id: "cpe301_064",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Why use symbolic constants instead of literal values?",
    options: [
      "They execute faster",
      "They make code more readable and easier to maintain",
      "They use less memory",
      "They are required by the assembler",
    ],
    correctAnswer: 1,
    explanation:
      "Symbolic constants improve code readability and make it easier to change values in one place.",
  },
  {
    id: "cpe301_065",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What happens if you try to redefine a symbol defined with EQU?",
    options: [
      "The assembler uses the new value",
      "The assembler generates an error",
      "The assembler ignores it",
      "The assembler generates a warning",
    ],
    correctAnswer: 1,
    explanation:
      "EQU symbols cannot be redefined; attempting to do so causes an assembly error.",
  },
  {
    id: "cpe301_066",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does INT stand for in assembly language?",
    options: ["Integer", "Internal", "Interrupt", "Interface"],
    correctAnswer: 2,
    explanation:
      "INT is the interrupt instruction that calls BIOS or DOS services.",
  },
  {
    id: "cpe301_067",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "In real-address mode, how do you typically specify which DOS function to call?",
    options: [
      "By setting a register value before the INT instruction",
      "By using different interrupt numbers",
      "By using different opcodes",
      "By passing parameters on the stack",
    ],
    correctAnswer: 0,
    explanation:
      "The AH register typically holds the function number for INT 21h DOS services.",
  },
  {
    id: "cpe301_068",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does INT 21h, function 2 do?",
    options: [
      "Read a character",
      "Write a character to standard output",
      "Terminate program",
      "Get system time",
    ],
    correctAnswer: 1,
    explanation:
      "INT 21h, function 2 displays the character in DL to standard output.",
  },
  {
    id: "cpe301_069",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What character should terminate a string for INT 21h, function 9?",
    options: [
      "Null (0)",
      "Dollar sign ($)",
      "Carriage return (13)",
      "Line feed (10)",
    ],
    correctAnswer: 1,
    explanation:
      "DOS function 9 expects strings to be terminated with a dollar sign ($) character.",
  },
  {
    id: "cpe301_070",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does INT 16h, function 0 do?",
    options: [
      "Display a character",
      "Wait for and read a keyboard character",
      "Check keyboard status",
      "Clear the keyboard buffer",
    ],
    correctAnswer: 1,
    explanation:
      "INT 16h, function 0 waits for a keystroke and returns the character.",
  },
  {
    id: "cpe301_071",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "In protected mode, what replaces direct BIOS and DOS interrupt calls?",
    options: [
      "Hardware interrupts",
      "Operating system API calls",
      "Direct memory access",
      "Nothing, they still work the same",
    ],
    correctAnswer: 1,
    explanation:
      "Protected mode OSes provide APIs (like Win32 API) instead of BIOS/DOS interrupts.",
  },
  {
    id: "cpe301_072",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does the WriteString procedure from Irvine32 do?",
    options: [
      "Writes a string to a file",
      "Displays a null-terminated string on the console",
      "Reads a string from the keyboard",
      "Converts a string to uppercase",
    ],
    correctAnswer: 1,
    explanation:
      "WriteString displays the null-terminated string pointed to by EDX.",
  },
  {
    id: "cpe301_073",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does the WriteDec procedure do?",
    options: [
      "Writes a decimal point",
      "Displays an unsigned integer in decimal",
      "Decrements and writes a value",
      "Writes a hexadecimal number",
    ],
    correctAnswer: 1,
    explanation:
      "WriteDec displays the unsigned integer in EAX as a decimal number.",
  },
  {
    id: "cpe301_074",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does Crlf (from Irvine32) do?",
    options: [
      "Clears the screen",
      "Writes a carriage return and line feed",
      "Clears a register",
      "Creates a new file",
    ],
    correctAnswer: 1,
    explanation:
      "Crlf outputs a newline (carriage return + line feed) to the console.",
  },
  {
    id: "cpe301_075",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does the Clrscr procedure do?",
    options: [
      "Clears a register",
      "Clears the screen",
      "Clears the stack",
      "Clears a string",
    ],
    correctAnswer: 1,
    explanation: "Clrscr (clear screen) clears the console window.",
  },
  {
    id: "cpe301_076",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Which instruction exchanges the values of two operands?",
    options: ["SWAP", "XCHG", "EXCHANGE", "SWITCH"],
    correctAnswer: 1,
    explanation: "XCHG (exchange) swaps the contents of two operands.",
  },
  {
    id: "cpe301_077",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Which instruction decrements a register by 1?",
    options: [
      "SUB register, 1",
      "DEC register",
      "DECREMENT register",
      "Both a and b",
    ],
    correctAnswer: 3,
    explanation:
      "Both SUB reg,1 and DEC reg decrease the value by 1, but DEC is more efficient.",
  },
  {
    id: "cpe301_078",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Which instruction performs two's complement negation?",
    options: ["NOT", "NEG", "NEGATE", "COMP"],
    correctAnswer: 1,
    explanation:
      "NEG performs two's complement negation: operand = 0 - operand.",
  },
  {
    id: "cpe301_079",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does the MOVZX instruction do?",
    options: [
      "Moves and zeros the destination",
      "Moves with zero extension (fills upper bits with 0)",
      "Moves only zero values",
      "Moves and XORs",
    ],
    correctAnswer: 1,
    explanation:
      "MOVZX (move with zero extend) copies a smaller value and fills upper bits with zeros.",
  },
  {
    id: "cpe301_080",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "If AL = 80h (10000000 binary) and you execute 'movzx eax, al', what is in EAX?",
    options: ["00000080h", "FFFFFF80h", "80808080h", "00000000h"],
    correctAnswer: 0,
    explanation: "MOVZX fills upper bits with 0, so 80h becomes 00000080h.",
  },
  {
    id: "cpe301_081",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "In 'mov eax, 25', what addressing mode is used for the source operand?",
    options: ["Register", "Immediate", "Direct", "Indirect"],
    correctAnswer: 1,
    explanation:
      "Immediate addressing: the value (25) is part of the instruction itself.",
  },
  {
    id: "cpe301_082",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "In 'mov eax, [var1]', what addressing mode is used for the source?",
    options: [
      "Immediate",
      "Register",
      "Direct (or displacement)",
      "Register indirect",
    ],
    correctAnswer: 2,
    explanation:
      "Direct addressing: the memory address is specified directly in the instruction.",
  },
  {
    id: "cpe301_083",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Move the value at the address contained in EBX into EAX",
    options: [
      "The actual data",
      "The address of the data",
      "An offset value",
      "A flag value",
    ],
    correctAnswer: 1,
    explanation:
      "The register holds a memory address (pointer) to the actual data.",
  },
  {
    id: "cpe301_084",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "In 'mov eax, [ebx+esi]', what is this addressing mode called?",
    options: ["Direct", "Base-indexed", "Displacement", "Immediate"],
    correctAnswer: 1,
    explanation:
      "Base-indexed addressing: EBX is the base, ESI is the index register.",
  },
  {
    id: "cpe301_085",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Can you use ESP as an index register in indexed addressing?",
    options: [
      "Yes, always",
      "No, ESP cannot be used as an index register",
      "Yes, but only in 64-bit mode",
      "Only with special prefixes",
    ],
    correctAnswer: 1,
    explanation:
      "ESP cannot be used as an index register in x86 addressing modes.",
  },
  {
    id: "cpe301_086",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What instruction is used to call a procedure?",
    options: ["JMP", "CALL", "PROC", "INVOKE"],
    correctAnswer: 1,
    explanation:
      "CALL instruction pushes the return address and jumps to the procedure.",
  },
  {
    id: "cpe301_087",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Which instruction returns from a procedure?",
    options: ["RETURN", "RET", "ENDP", "EXIT"],
    correctAnswer: 1,
    explanation:
      "RET (return) pops the return address from the stack and jumps to it.",
  },
  {
    id: "cpe301_088",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Pops the return address from the stack and jumps to it",
    options: ["STORE", "PUT", "PUSH", "SAVE"],
    correctAnswer: 2,
    explanation:
      "PUSH decrements ESP and stores the value at the new top of stack.",
  },
  {
    id: "cpe301_089",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What happens to ESP when you PUSH a value?",
    options: [
      "ESP increases",
      "ESP decreases",
      "ESP remains unchanged",
      "ESP is cleared",
    ],
    correctAnswer: 1,
    explanation:
      "The stack grows downward in memory, so PUSH decrements ESP (subtracts 4 for 32-bit).",
  },
  {
    id: "cpe301_090",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "In a procedure, what is a stack frame?",
    options: [
      "The size of the stack",
      "The area on the stack reserved for local variables and parameters",
      "The first element on the stack",
      "The last element on the stack",
    ],
    correctAnswer: 1,
    explanation:
      "A stack frame contains local variables, parameters, and saved registers for a procedure.",
  },
  {
    id: "cpe301_091",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What does the NOP instruction do?",
    options: [
      "Stops the program",
      "No operation (does nothing)",
      "Negates the operand",
      "Normalizes a value",
    ],
    correctAnswer: 1,
    explanation:
      "NOP performs no operation, simply advancing to the next instruction.",
  },
  {
    id: "cpe301_092",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What is the opcode for NOP?",
    options: ["00h", "90h", "FFh", "C3h"],
    correctAnswer: 1,
    explanation: "The machine code for NOP is 90h.",
  },
  {
    id: "cpe301_093",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "After a CMP instruction, which flags are typically affected?",
    options: [
      "Only Zero flag",
      "Only Carry flag",
      "Zero, Carry, Sign, Overflow, Parity",
      "No flags are affected",
    ],
    correctAnswer: 2,
    explanation: "CMP affects the same flags as SUB: ZF, CF, SF, OF, PF, AF.",
  },
  {
    id: "cpe301_094",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Performs a logical AND and sets flags without storing the result",
    options: ["AND", "LAND", "ANDB", "LOGICAL_AND"],
    correctAnswer: 0,
    explanation:
      "AND performs bitwise AND: destination = destination AND source.",
  },
  {
    id: "cpe301_095",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Which instruction performs a logical OR operation?",
    options: ["OR", "LOR", "ORB", "LOGICAL_OR"],
    correctAnswer: 0,
    explanation: "OR performs bitwise OR: destination = destination OR source.",
  },
  {
    id: "cpe301_096",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Why is 'xor reg, reg' commonly used to zero a register?",
    options: [
      "It's the only way",
      "It's faster and uses fewer bytes than 'mov reg, 0'",
      "It sets special flags",
      "It works on all processors",
    ],
    correctAnswer: 1,
    explanation:
      "XOR reg,reg is 2 bytes vs MOV reg,0 which is 5 bytes for 32-bit registers. It's also faster.",
  },
  {
    id: "cpe301_097",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What is the difference between NOT and NEG?",
    options: [
      "NOT is logical inversion, NEG is two's complement negation",
      "NOT is for unsigned, NEG is for signed",
      "There is no difference",
      "NOT works on bytes, NEG on words",
    ],
    correctAnswer: 0,
    explanation:
      "NOT inverts bits. NEG computes 0 - operand (two's complement: invert bits and add 1).",
  },
  {
    id: "cpe301_098",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "What happens to the rightmost bit when you execute SHL?",
    options: [
      "It's preserved",
      "It's filled with 0",
      "It's filled with 1",
      "It's filled with the sign bit",
    ],
    correctAnswer: 1,
    explanation:
      "SHL shifts bits left, with 0 filling in from the right. The leftmost bit goes to the carry flag.",
  },
  {
    id: "cpe301_099",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Which instruction shifts bits to the right, filling with zeros?",
    options: ["SHL", "SHR (logical shift right)", "SAR", "ROR"],
    correctAnswer: 1,
    explanation:
      "SHR (Shift Right) shifts bits right with 0 filling from the left.",
  },
  {
    id: "cpe301_100",
    course: "CPE 301",
    chapter: "Chapter 3",
    text: "Which instructions rotate bits without going through the carry flag?",
    options: ["RCL and RCR", "SHL and SHR", "ROL and ROR", "SAL and SAR"],
    correctAnswer: 2,
    explanation:
      "ROL (Rotate Left) and ROR (Rotate Right) rotate bits in a circular fashion without involving CF.",
  },
];

export default cpe301Chapter2;
