import { QuestionV2 } from "@/lib/quiz-types";

const CSC315_Lecturer3_Questions: QuestionV2[] = [
  // --- SINGLE-WORD BLANKS ---
  {
    id: "CSC315_L3_001",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Arrays are simple and fast but must specify size at ______ time.",
    options: ["Runtime", "Compile", "Construction", "Execution"],
    correctAnswer: 2,
    explanation:
      "From the slides: 'Arrays... Must specify size at construction time'.",
  },
  {
    id: "CSC315_L3_002",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "According to Murphy's law in the slides: 'Tomorrow you'll need ______'.",
    options: ["n-1", "n+1", "2n", "n^2"],
    correctAnswer: 1,
    explanation:
      "From the slides: 'Construct an array with space for n... Tomorrow you'll need n+1'.",
  },
  {
    id: "CSC315_L3_003",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Linked Lists allow ______ space use by allocating space for each element as needed.",
    options: ["Static", "Fixed", "Flexible", "Rigid"],
    correctAnswer: 2,
    explanation: "From the slides: 'Linked Lists... Flexible space use'.",
  },
  {
    id: "CSC315_L3_004",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The collection structure has a pointer to the list head, which is initially ______.",
    options: ["VOID", "ZERO", "NULL", "EMPTY"],
    correctAnswer: 2,
    explanation:
      "From the slides: 'Collection structure has a pointer to the list head Initially NULL'.",
  },
  {
    id: "CSC315_L3_005",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In B+ trees, all the keys in the nodes are ______.",
    options: ["Pointers", "Data", "Real", "Dummies"],
    correctAnswer: 3,
    explanation:
      "From B+ trees section: 'All the keys in the nodes are dummies'.",
  },
  {
    id: "CSC315_L3_006",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In B+ trees, only the keys in the leaves point to ______ data.",
    options: ["Abstract", "Real", "Meta", "Cached"],
    correctAnswer: 1,
    explanation:
      "From B+ trees section: 'Only the keys in the leaves point to “real” data'.",
  },
  {
    id: "CSC315_L3_007",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Reading a disc block is much slower than reading memory (~______ vs ~ns).",
    options: ["s", "ms", "us", "min"],
    correctAnswer: 1,
    explanation:
      "From B-trees Use section: 'Reading a disc block is much slower than reading memory ( ~ms vs ~ns )'.",
  },
  {
    id: "CSC315_L3_008",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "B-tree property: block is at least ______ of keys.",
    options: ["Full", "Quarter-full", "Half-full", "Empty"],
    correctAnswer: 2,
    explanation:
      "From B-trees Insertion: 'B-tree property : block is at least half-full of keys'.",
  },
  {
    id: "CSC315_L3_009",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "When a B-tree node overflows, we must ______ it.",
    options: ["Delete", "Merge", "Split", "Copy"],
    correctAnswer: 2,
    explanation: "From B-trees Insertion: 'Leaf node overflows, split it'.",
  },
  {
    id: "CSC315_L3_010",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "If the root of a B-tree is split, the tree becomes one level ______.",
    options: ["Wider", "Deeper", "Shallower", "Smaller"],
    correctAnswer: 1,
    explanation:
      "From B-trees Insertion: 'if root is split, tree becomes one level deeper'.",
  },
  {
    id: "CSC315_L3_011",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Disc blocks typically range from 512 to ______ bytes.",
    options: ["1k", "2k", "4k", "8k"],
    correctAnswer: 3,
    explanation: "From B-trees on disc: 'Disc blocks 512 - 8k bytes'.",
  },
  {
    id: "CSC315_L3_012",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "A Stack data structure follows the ______ principle.",
    options: ["FIFO", "LIFO", "GIGO", "FILO"],
    correctAnswer: 1,
    explanation:
      "Standard definition from Stack section: Last In First Out (LIFO).",
  },
  {
    id: "CSC315_L3_013",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The operation to add an element to a stack is called ______.",
    options: ["Pop", "Peek", "Push", "Add"],
    correctAnswer: 2,
    explanation: "Standard Stack operation: Push.",
  },
  {
    id: "CSC315_L3_014",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The operation to remove an element from a stack is called ______.",
    options: ["Push", "Delete", "Pop", "Remove"],
    correctAnswer: 2,
    explanation: "Standard Stack operation: Pop.",
  },
  {
    id: "CSC315_L3_015",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "A Queue data structure follows the ______ principle.",
    options: ["LIFO", "FIFO", "LILO", "Random"],
    correctAnswer: 1,
    explanation:
      "Standard definition from Queue section: First In First Out (FIFO).",
  },
  {
    id: "CSC315_L3_016",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In a linked list, each node contains a ______ to the next item.",
    options: ["Key", "Index", "Pointer", "Value"],
    correctAnswer: 2,
    explanation: "From slides: 'Include a pointer to the next item'.",
  },
  {
    id: "CSC315_L3_017",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "To add the first item to a linked list, we set Head to point to the ______ node.",
    options: ["Null", "Last", "New", "Old"],
    correctAnswer: 2,
    explanation: "From slides: 'Set Head to point to new node'.",
  },
  {
    id: "CSC315_L3_018",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "When adding a second item, we set the new node's Next to the current ______.",
    options: ["Tail", "Head", "Null", "Data"],
    correctAnswer: 1,
    explanation: "From slides: 'Set Next to current Head'.",
  },
  {
    id: "CSC315_L3_019",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In a B-tree, when a node is split, we ______ one key to the parent.",
    options: ["Demote", "Delete", "Promote", "Copy"],
    correctAnswer: 2,
    explanation: "From B-trees Insertion: 'split block, promote one key'.",
  },
  {
    id: "CSC315_L3_020",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "B+ trees allow us to scan the collection in order without passing through the ______ nodes.",
    options: ["Leaf", "Higher", "Root", "Data"],
    correctAnswer: 1,
    explanation:
      "From B+ trees section: 'Ability to scan the collection in order without passing through the higher nodes'.",
  },

  // --- MULTI-WORD BLANKS ---
  {
    id: "CSC315_L3_021",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Arrays are described as ______ but having limitations on size flexibility.",
    options: [
      "Simple, Fast",
      "Complex, Slow",
      "Dynamic, Robust",
      "Abstract, Secure",
    ],
    correctAnswer: 0,
    explanation:
      "From slides: 'Arrays: Simple, Fast but Must specify size...'.",
  },
  {
    id: "CSC315_L3_022",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Linked Lists are capable of ______ space use.",
    options: [
      "Static and Rigid",
      "Flexible and Dynamic",
      "Fixed and Linear",
      "Abstract and Virtual",
    ],
    correctAnswer: 1,
    explanation:
      "From slides: 'Linked Lists: Flexible space use, Dynamically allocate space...'.",
  },
  {
    id: "CSC315_L3_023",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In the ADT for Linked Lists, the data item is often represented as an ______.",
    options: [
      "Integer value",
      "Object pointer",
      "Array index",
      "String literal",
    ],
    correctAnswer: 1,
    explanation: "From slides: 'the data item (an object pointer in our ADT)'.",
  },
  {
    id: "CSC315_L3_024",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "When adding a node, we must allocate space for the node and set its ______ to the object.",
    options: ["Next pointer", "Head reference", "Data pointer", "Tail index"],
    correctAnswer: 2,
    explanation:
      "From slides: 'Allocate space for node, Set its data pointer to object'.",
  },
  {
    id: "CSC315_L3_025",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In B+ trees, data records are kept in a ______.",
    options: [
      "Shared memory block",
      "Root node only",
      "Separate area",
      "Higher level node",
    ],
    correctAnswer: 2,
    explanation:
      "From B+ trees section: 'Data records kept in a separate area'.",
  },
  {
    id: "CSC315_L3_026",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "For Large Databases, B+ trees are useful because reading a ______ is much slower than reading memory.",
    options: ["Cache line", "Register value", "Disc block", "Network packet"],
    correctAnswer: 2,
    explanation:
      "From B+ trees Use: 'Reading a disc block is much slower than reading memory'.",
  },
  {
    id: "CSC315_L3_027",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "When a leaf node overflows in a B-tree, we split it and ______ the middle key.",
    options: ["Delete", "Demote", "Promote", "Hide"],
    correctAnswer: 2,
    explanation:
      "From B-trees Insertion example: 'Leaf node overflows, split it, Promote middle'.",
  },
  {
    id: "CSC315_L3_028",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The B+ tree structure allows for ______ of the leaves.",
    options: ["Random access", "Recursive deletion", "Linking", "Hashing"],
    correctAnswer: 2,
    explanation: "From B+ trees section: 'Linking the leaves'.",
  },
  {
    id: "CSC315_L3_029",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In a linked list implementation, the struct `t_node` contains `void *item` and ______.",
    options: ["int size", "struct t_node *next", "char *data", "float value"],
    correctAnswer: 1,
    explanation:
      "From Implementation slide: 'struct t_node { void *item; struct t_node *next; }'.",
  },
  {
    id: "CSC315_L3_030",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Ideally, B-trees put each ______ in one disc block.",
    options: ["Data object", "Block of keys", "Linked list", "Hash table"],
    correctAnswer: 1,
    explanation:
      "From Use - Large Databases: 'Put each block of keys in one disc block'.",
  },

  // --- LIST-STYLE BLANKS ---
  {
    id: "CSC315_L3_031",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Each node of the list contains: (1) ______ (2) ______.",
    options: [
      "Index, Value",
      "Data item, Pointer to next node",
      "Key, Hash",
      "Head, Tail",
    ],
    correctAnswer: 1,
    explanation:
      "From slides: 'Each node of the list contains: the data item... a pointer to the next node'.",
  },
  {
    id: "CSC315_L3_032",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "When adding the first item to a linked list: (1) Allocate space for node (2) Set data pointer (3) ______ (4) Set Head to point to new node.",
    options: [
      "Set Head to NULL",
      "Set Next to NULL",
      "Set Tail to Head",
      "Set Size to 0",
    ],
    correctAnswer: 1,
    explanation: "From slides: 'Set Next to NULL' is the third step listed.",
  },
  {
    id: "CSC315_L3_033",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Insertion into a B-tree block with m keys involves: (1) block overflows (2) split block (3) ______ (4) split parent if necessary.",
    options: ["delete key", "promote one key", "rotate tree", "merge leaves"],
    correctAnswer: 1,
    explanation:
      "From B-trees Insertion: 'promote one key' follows splitting the block.",
  },
  {
    id: "CSC315_L3_034",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "B+ trees features: (1) ______ (2) Ability to scan collection in order without passing through higher nodes.",
    options: [
      "Linking the leaves",
      "Storing data in root",
      "Recursive hashing",
      "Dynamic sizing",
    ],
    correctAnswer: 0,
    explanation:
      "From B+ trees section: 'Linking the leaves' is the first feature listed.",
  },
  {
    id: "CSC315_L3_035",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "To add a second item to a Linked List: (1) Allocate space (2) Set data pointer (3) ______ (4) Set Head to point to new node.",
    options: [
      "Set Next to NULL",
      "Set Next to current Head",
      "Set Head to NULL",
      "Set Tail to Next",
    ],
    correctAnswer: 1,
    explanation: "From slides Add second item: 'Set Next to current Head'.",
  },
  {
    id: "CSC315_L3_036",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Array limitations include: (1) Must specify size at construction (2) ______ (3) Need n+1 space tomorrow.",
    options: [
      "Slow access time",
      "Complex implementation",
      "Murphy's law",
      "High memory overhead",
    ],
    correctAnswer: 2,
    explanation:
      "From slides: 'Murphy's law' is listed under Array Limitations.",
  },
  {
    id: "CSC315_L3_037",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Linked Lists benefits: (1) ______ (2) Dynamically allocate space as needed (3) Include pointer to next item.",
    options: [
      "Fixed space use",
      "Flexible space use",
      "Indexed access",
      "Contiguous memory",
    ],
    correctAnswer: 1,
    explanation: "From slides: 'Flexible space use' is the first benefit.",
  },
  {
    id: "CSC315_L3_038",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "B-tree insertion example: (1) Insert 9 (2) Leaf node overflows, split it (3) ______ (4) Root overflows, split it.",
    options: [
      "Promote middle (8)",
      "Delete root",
      "Merge with sibling",
      "Rotate left",
    ],
    correctAnswer: 0,
    explanation: "From B-trees Insertion example: 'Promote middle (8)'.",
  },
  {
    id: "CSC315_L3_039",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Use of B+ trees for Large Databases: (1) ______ (2) Put each block of keys in one disc block.",
    options: [
      "Reading disc is fast",
      "Reading disc is slower than memory",
      "Memory is unlimited",
      "Processors are slow",
    ],
    correctAnswer: 1,
    explanation:
      "From Use section: 'Reading a disc block is much slower than reading memory'.",
  },
  {
    id: "CSC315_L3_040",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Types of Data Structures covered in the intro: (1) Linked Lists (2) ______ (3) B-trees.",
    options: ["Stacks", "Integers", "Floats", "Strings"],
    correctAnswer: 0,
    explanation: "From Page 1 snippet: 'Linked Lists Stacks'.",
  },

  // --- DEFINITION/EXPLANATION BLANKS ---
  {
    id: "CSC315_L3_041",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The definition of a Linked List node is: ____________________________________________________",
    options: [
      "A contiguous block of memory containing data.",
      "A structure containing a data item and a pointer to the next node.",
      "An index pointing to an array element.",
      "A static collection of items.",
    ],
    correctAnswer: 1,
    explanation:
      "From slides: 'Each node of the list contains the data item... a pointer to the next node'.",
  },
  {
    id: "CSC315_L3_042",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The main limitation of Arrays described in the slides is: ____________________________________________________",
    options: [
      "They are slow to access.",
      "They use pointers which consume memory.",
      "Must specify size at construction time (Murphy's law).",
      "They cannot store integers.",
    ],
    correctAnswer: 2,
    explanation:
      "From Array Limitations: 'Must specify size at construction time'.",
  },
  {
    id: "CSC315_L3_043",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The definition of a B+ tree includes: ____________________________________________________",
    options: [
      "All keys in nodes are real data.",
      "All keys in nodes are dummies, only leaves point to real data.",
      "It is a binary tree with random insertion.",
      "It stores data in the root node only.",
    ],
    correctAnswer: 1,
    explanation:
      "From B+ trees section: 'All the keys in the nodes are dummies. Only the keys in the leaves point to “real” data'.",
  },
  {
    id: "CSC315_L3_044",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The purpose of 'Promoting a key' in B-tree insertion is: ____________________________________________________",
    options: [
      "To fill empty space in the leaves.",
      "To handle block overflow by moving a key up to the parent.",
      "To delete a key from the tree.",
      "To balance the tree by rotation.",
    ],
    correctAnswer: 1,
    explanation:
      "Contextual explanation from 'split block... promote one key... split parent if necessary'.",
  },
  {
    id: "CSC315_L3_045",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The definition of Flexible Space Use in Linked Lists means: ____________________________________________________",
    options: [
      "Allocating a large block of memory at start.",
      "Dynamically allocating space for each element as needed.",
      "Compressing data to fit in memory.",
      "Using virtual memory on disc.",
    ],
    correctAnswer: 1,
    explanation:
      "From slides: 'Flexible space use: Dynamically allocate space for each element as needed'.",
  },
  {
    id: "CSC315_L3_046",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The reason B+ trees are used in Large Databases is: ____________________________________________________",
    options: [
      "They are easier to implement in C++.",
      "They optimize for the slowness of reading disc blocks vs memory.",
      "They use less memory than binary trees.",
      "They support O(1) insertion time.",
    ],
    correctAnswer: 1,
    explanation:
      "From Use section: 'Reading a disc block is much slower... Put each block of keys in one disc block'.",
  },
  {
    id: "CSC315_L3_047",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The 'Next' pointer in the last node of a simple linked list is: ____________________________________________________",
    options: [
      "Pointed to the Head.",
      "Pointed to the previous node.",
      "NULL.",
      "Undefined.",
    ],
    correctAnswer: 2,
    explanation:
      "Inferred from standard linked list definition and initialization to NULL.",
  },
  {
    id: "CSC315_L3_048",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The definition of 'B-tree property' regarding block fullness is: ____________________________________________________",
    options: [
      "Block must be completely full.",
      "Block is at least half-full of keys.",
      "Block can be empty.",
      "Block size is variable.",
    ],
    correctAnswer: 1,
    explanation:
      "From B-trees Insertion: 'B-tree property : block is at least half-full of keys'.",
  },
  {
    id: "CSC315_L3_049",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The 'Head' pointer in a Collection structure for a Linked List is initially: ____________________________________________________",
    options: [
      "Pointing to the first node.",
      "Undefined.",
      "NULL.",
      "Pointing to itself.",
    ],
    correctAnswer: 2,
    explanation:
      "From slides: 'Collection structure has a pointer to the list head Initially NULL'.",
  },
  {
    id: "CSC315_L3_050",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The 'Scanning in order' capability of B+ trees means: ____________________________________________________",
    options: [
      "We must visit the root for every key.",
      "We can scan the collection via linked leaves without passing through higher nodes.",
      "We sort the data before insertion.",
      "We use recursion to find keys.",
    ],
    correctAnswer: 1,
    explanation:
      "From B+ trees Scanning: 'Ability to scan the collection in order without passing through the higher nodes'.",
  },

  // --- MIXED FORMATS (ADDITIONAL / INFERRED) ---
  {
    id: "CSC315_L3_051",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In the context of 'Murphy's law' for arrays, n represents ______.",
    options: [
      "The exact size needed",
      "Twice your estimate of largest collection",
      "The minimum size",
      "The number of pointers",
    ],
    correctAnswer: 1,
    explanation:
      "From slides: 'Construct an array with space for n... n = twice your estimate of largest collection'.",
  },
  {
    id: "CSC315_L3_052",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "When splitting a B-tree root, the tree height increases by ______.",
    options: ["0", "1", "2", "n"],
    correctAnswer: 1,
    explanation: "From B-trees Insertion: 'Height increased by 1'.",
  },
  {
    id: "CSC315_L3_053",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The typical unit for memory reading speed mentioned is ______.",
    options: ["ms", "ns", "s", "min"],
    correctAnswer: 1,
    explanation: "From Use section: '~ns' for memory.",
  },
  {
    id: "CSC315_L3_054",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The typical unit for disc block reading speed mentioned is ______.",
    options: ["ms", "ns", "us", "ps"],
    correctAnswer: 0,
    explanation: "From Use section: '~ms' for disc.",
  },
  {
    id: "CSC315_L3_055",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In B+ trees, the keys in the leaves are the only ones that point to ______.",
    options: ["Other leaves", "The root", "Real data", "Null"],
    correctAnswer: 2,
    explanation:
      "From B+ trees: 'Only the keys in the leaves point to real data'.",
  },
  {
    id: "CSC315_L3_056",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "A linked list node implementation usually involves a struct with a ______ pointer.",
    options: ["void *", "struct t_node *", "int *", "char *"],
    correctAnswer: 1,
    explanation: "From Implementation slide: 'struct t_node *next'.",
  },
  {
    id: "CSC315_L3_057",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "When inserting 9 into the B-tree example, the leaf node ______.",
    options: ["Accepts it", "Overflows", "Deletes it", "Rotates"],
    correctAnswer: 1,
    explanation: "From Insertion example: 'Insert 9... Leaf node overflows'.",
  },
  {
    id: "CSC315_L3_058",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The data item in the Linked List ADT example is defined as an ______.",
    options: ["Object pointer", "Integer", "Array", "String"],
    correctAnswer: 0,
    explanation: "From slides: 'the data item (an object pointer in our ADT)'.",
  },
  {
    id: "CSC315_L3_059",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Array construction requires specifying size at ______.",
    options: ["Run time", "Construction time", "Deletion time", "Access time"],
    correctAnswer: 1,
    explanation: "From slides: 'Must specify size at construction time'.",
  },
  {
    id: "CSC315_L3_060",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "B+ trees differ from B-trees in that B+ trees link the ______.",
    options: ["Roots", "Branches", "Leaves", "Parents"],
    correctAnswer: 2,
    explanation: "From B+ trees: 'Linking the leaves'.",
  },
  {
    id: "CSC315_L3_061",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "If `Head` is NULL, the linked list is considered ______.",
    options: ["Full", "Empty", "Broken", "Initialized"],
    correctAnswer: 1,
    explanation:
      "Implied from 'Initially NULL' representing an empty list state.",
  },
  {
    id: "CSC315_L3_062",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The middle key (e.g., 8 in the example) is ______ when a node splits.",
    options: ["Deleted", "Demoted", "Promoted", "Copied"],
    correctAnswer: 2,
    explanation: "From Insertion example: 'Promote middle (8)'.",
  },
  {
    id: "CSC315_L3_063",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Disc blocks are mentioned to be up to ______ in size.",
    options: ["4k", "8k", "16k", "32k"],
    correctAnswer: 1,
    explanation: "From B-trees on disc: '512 - 8k bytes'.",
  },
  {
    id: "CSC315_L3_064",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In the Linked List ADT, `void *item` allows the list to store ______.",
    options: [
      "Only integers",
      "Only strings",
      "Any type of data",
      "Only pointers",
    ],
    correctAnswer: 2,
    explanation: "In C, `void *` is a generic pointer allowing any data type.",
  },
  {
    id: "CSC315_L3_065",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The structure that contains the list head is called the ______ structure.",
    options: ["Node", "Collection", "Root", "Base"],
    correctAnswer: 1,
    explanation:
      "From slides: 'Collection structure has a pointer to the list head'.",
  },
  {
    id: "CSC315_L3_066",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "A Stack is often implemented using either an array or a ______.",
    options: ["Tree", "Graph", "Linked List", "Hash Map"],
    correctAnswer: 2,
    explanation: "Standard data structure implementations.",
  },
  {
    id: "CSC315_L3_067",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Which operation is NOT typically associated with a Stack?",
    options: ["Push", "Pop", "Enqueue", "Peek"],
    correctAnswer: 2,
    explanation: "Enqueue is a Queue operation.",
  },
  {
    id: "CSC315_L3_068",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Which operation is NOT typically associated with a Queue?",
    options: ["Enqueue", "Dequeue", "Push", "Peek"],
    correctAnswer: 2,
    explanation: "Push is typically a Stack operation.",
  },
  {
    id: "CSC315_L3_069",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In a binary tree, a node with no children is called a ______.",
    options: ["Root", "Branch", "Leaf", "Stem"],
    correctAnswer: 2,
    explanation: "Standard Tree definition.",
  },
  {
    id: "CSC315_L3_070",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The depth of the root node is ______.",
    options: ["0", "1", "-1", "Infinite"],
    correctAnswer: 0,
    explanation: "Standard Tree depth definition.",
  },
  {
    id: "CSC315_L3_071",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "A Binary Search Tree (BST) property states that for any node, left children are ______ than the node.",
    options: ["Greater", "Equal", "Smaller", "Unrelated"],
    correctAnswer: 2,
    explanation: "Standard BST property.",
  },
  {
    id: "CSC315_L3_072",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The main advantage of B-trees over BSTs for disc storage is minimizing ______.",
    options: [
      "Comparisons",
      "Disc I/O operations",
      "Memory usage",
      "Code complexity",
    ],
    correctAnswer: 1,
    explanation: "Implied from B-trees use section regarding disc block speed.",
  },
  {
    id: "CSC315_L3_073",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In a Max-Heap, the root always contains the ______ element.",
    options: ["Smallest", "Largest", "Median", "Random"],
    correctAnswer: 1,
    explanation: "Standard Heap property.",
  },
  {
    id: "CSC315_L3_074",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Hash tables use a ______ function to map keys to indices.",
    options: ["Sort", "Hash", "Search", "Merge"],
    correctAnswer: 1,
    explanation: "Standard Hash Table definition.",
  },
  {
    id: "CSC315_L3_075",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "A collision in a Hash Table occurs when two keys map to ______.",
    options: ["Different indices", "The same index", "Null", "Negative values"],
    correctAnswer: 1,
    explanation: "Standard Hash Table collision definition.",
  },
];

export const CSC315_Sorting_Questions: QuestionV2[] = [
  // --- SINGLE-WORD BLANKS ---
  {
    id: "CSC315_SORT_001",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Sorting usually refers to bringing a set of items into some well-defined ______.",
    options: ["Group", "Order", "Class", "Structure"],
    correctAnswer: 1,
    explanation:
      "From Page 104: 'sorting usually refers to bringing a set of items into some well-defined order'.",
  },
  {
    id: "CSC315_SORT_002",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Sorting is closely related to the problem of ______.",
    options: ["Hashing", "Indexing", "Search", "Merging"],
    correctAnswer: 2,
    explanation:
      "From Page 105: 'It is thus closely related to the problem of search'.",
  },
  {
    id: "CSC315_SORT_003",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Bubble Sort follows the ______ sort approach.",
    options: ["Insertion", "Selection", "Exchange", "Partition"],
    correctAnswer: 2,
    explanation:
      "From Page 106: 'Bubble Sort follows the exchange sort approach'.",
  },
  {
    id: "CSC315_SORT_004",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Insertion Sort works efficiently on data which is already ______.",
    options: ["Random", "Reversed", "Large", "Sorted"],
    correctAnswer: 3,
    explanation:
      "From Page 110: 'Insertion Sort does particularly well on data which is sorted already'.",
  },
  {
    id: "CSC315_SORT_005",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Selection Sort always makes n(n-1)/2 ______.",
    options: ["Swaps", "Moves", "Comparisons", "Errors"],
    correctAnswer: 2,
    explanation:
      "From Page 110: 'Selection Sort always makes n(n-1)/2 comparisons'.",
  },
  {
    id: "CSC315_SORT_006",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The sorting algorithm that uses a pivot is called ______.",
    options: ["Mergesort", "Heapsort", "Quicksort", "Bubblesort"],
    correctAnswer: 2,
    explanation:
      "From Page 115: 'The value that defines the split is called the pivot... standard Quicksort strategy'.",
  },
  {
    id: "CSC315_SORT_007",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Mergesort splits the array at each stage into its first and last ______.",
    options: ["Third", "Quarter", "Half", "Segment"],
    correctAnswer: 2,
    explanation:
      "From Page 119: 'simply splits the array at each stage into its first and last half'.",
  },
  {
    id: "CSC315_SORT_008",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "A sorting algorithm is ______ if it preserves the order of identical keys.",
    options: ["Fast", "Stable", "Linear", "Complex"],
    correctAnswer: 1,
    explanation:
      "From Page 112: 'Lecturer 3 which satisfy this useful property are said to be stable'.",
  },
  {
    id: "CSC315_SORT_009",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Heapsort uses a ______ tree to sort items.",
    options: ["Binary Search", "AVL", "Binary Heap", "B-Tree"],
    correctAnswer: 2,
    explanation: "From Page 113: 'make use of binary heap trees'.",
  },
  {
    id: "CSC315_SORT_010",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The lower bound for comparison-based sorting complexity is ______.",
    options: ["O(n)", "O(n^2)", "O(n log n)", "O(log n)"],
    correctAnswer: 2,
    explanation:
      "From Page 65: 'no algorithm can actually take fewer than O(n log n) comparisons'.",
  },

  // --- MULTI-WORD BLANKS ---
  {
    id: "CSC315_SORT_011",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Internal Lecturer 3 assume that all items to be sorted will fit into the ______.",
    options: [
      "Hard drive",
      "External storage",
      "Computer's internal memory",
      "Cache memory",
    ],
    correctAnswer: 2,
    explanation:
      "From Page 105: 'assumption that all the items to be sorted will fit into the computer’s internal memory'.",
  },
  {
    id: "CSC315_SORT_012",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "If a collection is already sorted, we need at least ______ steps to examine every element.",
    options: ["n log n", "n^2", "n", "1"],
    correctAnswer: 2,
    explanation:
      "From Page 65: 'lower bound must be at least n... since we need at least n steps to examine every element'.",
  },
  {
    id: "CSC315_SORT_013",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The average and worst case time complexities of Bubble Sort are both ______.",
    options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"],
    correctAnswer: 2,
    explanation:
      "From Page 107: 'Thus the worst case and average case... are both proportional to n^2'.",
  },
  {
    id: "CSC315_SORT_014",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "In Selection Sort, there is exactly ______ for each iteration of the outer loop.",
    options: ["One comparison", "One swap", "Two swaps", "Zero swaps"],
    correctAnswer: 1,
    explanation:
      "From Page 109: 'there is exactly one swap for each iteration of the outer loop'.",
  },
  {
    id: "CSC315_SORT_015",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Treesort can be difficult to compare because it returns a ______ rather than an array.",
    options: ["List", "Heap", "Tree", "File"],
    correctAnswer: 2,
    explanation:
      "From Page 112: 'Treesort can be difficult to compare... since it returns a tree, rather than an array'.",
  },
  {
    id: "CSC315_SORT_016",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The total number of comparisons in the worst case for Quicksort is ______.",
    options: ["O(n)", "O(n log n)", "O(n^2)", "O(1)"],
    correctAnswer: 2,
    explanation:
      "From Page 118: 'in the worst case, the number of comparisons performed by Quicksort is O(n^2)'.",
  },
  {
    id: "CSC315_SORT_017",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "To render Quicksort stable, the partitioning must be done such that the order of ______ is never reversed.",
    options: ["Large items", "Small items", "Identical items", "Pivot items"],
    correctAnswer: 2,
    explanation:
      "From Page 117: 'To render quicksort stable... order of identical items can never be reversed'.",
  },
  {
    id: "CSC315_SORT_018",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Mergesort is a ______ algorithm that recursively splits the sorting problem.",
    options: [
      "Greedy",
      "Divide and conquer",
      "Dynamic programming",
      "Backtracking",
    ],
    correctAnswer: 1,
    explanation:
      "From Page 114: 'divide and conquer algorithms recursively split the sorting problem'.",
  },
  {
    id: "CSC315_SORT_019",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "______ is the underlying idea for a sorting algorithm called mergesort.",
    options: [
      "Splitting by pivot",
      "Splitting by index",
      "Splitting by value",
      "Splitting by type",
    ],
    correctAnswer: 1,
    explanation:
      "From Page 114: 'split the set of indices... is the underlying idea for... mergesort'.",
  },
  {
    id: "CSC315_SORT_020",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The complexity of the heapify algorithm to rearrange an unsorted array into a heap tree is ______.",
    options: ["O(1)", "O(n)", "O(n log n)", "O(n^2)"],
    correctAnswer: 1,
    explanation:
      "From Page 113: 'heapify algorithm which can do that with O(n) time complexity'.",
  },

  // --- LIST-STYLE BLANKS ---
  {
    id: "CSC315_SORT_021",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Key sorting strategies include: (1) Enumeration sorting, (2) Exchange sorting, (3) Selection sorting, and (4) ______.",
    options: [
      "Deletion sorting",
      "Insertion sorting",
      "Random sorting",
      "Linear sorting",
    ],
    correctAnswer: 1,
    explanation:
      "From Page 105: Lists strategies including 'insertion sorting'.",
  },
  {
    id: "CSC315_SORT_022",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Divide and conquer approaches in sorting: (1) ______ (2) Quicksort.",
    options: ["Mergesort", "Heapsort", "Bubblesort", "Treesort"],
    correctAnswer: 0,
    explanation:
      "From Page 114: Mentions 'mergesort' and 'Quicksort' as the two main approaches.",
  },
  {
    id: "CSC315_SORT_023",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Heuristic pivot choice strategies for Quicksort: (1) Use random number, (2) Take 'middle' key a[(n-1)/2], (3) ______.",
    options: [
      "Take the first item",
      "Take the last item",
      "Take a small sample and find middle",
      "Take the largest item",
    ],
    correctAnswer: 2,
    explanation:
      "From Page 116: 'Take a small sample (e.g., 3 or 5 items) and take the middle key'.",
  },
  {
    id: "CSC315_SORT_024",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Comparison of O(n^2) algorithms: (1) Bubble Sort, (2) Selection Sort, (3) ______.",
    options: ["Heapsort", "Insertion Sort", "Mergesort", "Quicksort"],
    correctAnswer: 1,
    explanation:
      "From Page 110: The table compares Bubble, Selection, and Insertion Sort.",
  },
  {
    id: "CSC315_SORT_025",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Stable Lecturer 3 include: (1) Bubble Sort, (2) Insertion Sort, (3) ______.",
    options: ["Selection Sort", "Heapsort", "Quicksort", "Mergesort"],
    correctAnswer: 3,
    explanation:
      "From Page 121 (Summary Table): Mergesort is marked as Stable.",
  },
  {
    id: "CSC315_SORT_026",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "Unstable Lecturer 3 include: (1) Selection Sort, (2) ______.",
    options: ["Insertion Sort", "Bubble Sort", "Heapsort", "Mergesort"],
    correctAnswer: 2,
    explanation:
      "From Page 121 (Summary Table): Heapsort is marked as No (not stable).",
  },

  // --- DEFINITION/EXPLANATION BLANKS ---
  {
    id: "CSC315_SORT_027",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The definition of Stability in sorting is: ____________________________________________________",
    options: [
      "The algorithm never crashes.",
      "The algorithm always takes the same amount of time.",
      "Items with identical keys are kept in their original order.",
      "The algorithm uses constant memory.",
    ],
    correctAnswer: 2,
    explanation:
      "From Page 112: 'items with identical keys are kept in their original order... said to be stable'.",
  },
  {
    id: "CSC315_SORT_028",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The definition of Exchange Sorting is: ____________________________________________________",
    options: [
      "Find the smallest item and put it in the first position.",
      "Split the problem into smaller sub-problems.",
      "If two items are found to be out of order, exchange them.",
      "Take items one at a time and insert them into a structure.",
    ],
    correctAnswer: 2,
    explanation:
      "From Page 105: 'exchange sorting: If two items are found to be out of order, exchange them'.",
  },
  {
    id: "CSC315_SORT_029",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The principle of Merging two sorted collections is: ____________________________________________________",
    options: [
      "Concatenate the second collection to the end of the first.",
      "Compare the smallest items of both collections and pick the smaller one repeatedly.",
      "Sort the combined collection from scratch.",
      "Swap elements until both are sorted.",
    ],
    correctAnswer: 1,
    explanation:
      "From Page 119: 'smallest item overall must be either the smallest item in the first... or second collection'.",
  },
  {
    id: "CSC315_SORT_030",
    course: "CSC 315",
    chapter: "Lecturer 3",
    text: "The meaning of a Pivot in Quicksort is: ____________________________________________________",
    options: [
      "The index where the array is split in half.",
      "The value used to separate items into those smaller and those larger than itself.",
      "The first element of the array.",
      "The number of swaps performed.",
    ],
    correctAnswer: 1,
    explanation:
      "From Page 115: 'The value that defines the split is called the pivot... moving all items smaller... into one sub-array'.",
  },
];

const cpe315Lecturer3: QuestionV2[] = [
  ...CSC315_Lecturer3_Questions,
  ...CSC315_Sorting_Questions,
];

export default cpe315Lecturer3;
